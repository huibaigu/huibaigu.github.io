<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灰白骨的blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.scwyl.cn/"/>
  <updated>2019-08-28T16:01:15.927Z</updated>
  <id>http://www.scwyl.cn/</id>
  
  <author>
    <name>灰白骨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++网站壁纸获取</title>
    <link href="http://www.scwyl.cn/2019/08/29/%E5%A3%81%E7%BA%B8%E8%8E%B7%E5%8F%96/"/>
    <id>http://www.scwyl.cn/2019/08/29/壁纸获取/</id>
    <published>2019-08-28T17:00:00.000Z</published>
    <updated>2019-08-28T16:01:15.927Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/document/壁纸获取源码.rar">下载源码</a>     <a href="/document/壁纸获取软件.rar">下载工具</a></p><p>源码我是在VS2019上使用c++的控制台应用写的</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家都知道壁纸怎么下载，但是会有一种情况，一张页面上的壁纸非常多，下了半天才下完，我冥思苦想，想去找一个软件可以输入url地址就可以下载完那一页的壁纸。在网上找了找，基本我都用不了，于是考虑自己写一个。</p><a id="more"></a><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>1.通过url地址下载页面</p><p>2.建立以时间为名的文件夹下</p><p>3.判断页面里面的img标签</p><p>4.获取img标签里的地址</p><p>5.通过URLDownloadToFileA函数下载</p><p>6.循环下去</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>对于想法1</p><p>可以这样 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scanf_s(<span class="string">"%s"</span>, url, <span class="keyword">sizeof</span>(url));</span><br><span class="line"><span class="keyword">if</span> (downURL(url, sy) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Sleep(<span class="number">1000</span>);</span><br><span class="line">    read();</span><br><span class="line">    Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取url地址，然后通过downURL函数下载，保存为sy文件，如果成功就进行read();</p><p>对于想法2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> folderPath;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">t</span>;</span>   <span class="comment">//tm结构指针</span></span><br><span class="line"><span class="keyword">time_t</span> now;  <span class="comment">//声明time_t类型变量</span></span><br><span class="line">time(&amp;now);      <span class="comment">//获取系统日期和时间</span></span><br><span class="line">localtime_s(&amp;t, &amp;now);   <span class="comment">//获取当地日期和时间</span></span><br><span class="line">strftime(cNowTime, <span class="keyword">sizeof</span>(cNowTime), <span class="string">"%Y%m%d-%H%M%S"</span>, &amp;t);</span><br><span class="line">_mkdir(cNowTime);</span><br><span class="line">CreateDirectoryA(folderPath.c_str(), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>下面是downURL函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">downURL</span><span class="params">(<span class="keyword">char</span> *URL地址,<span class="keyword">char</span> *保存文件名)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HRESULT hr = URLDownloadToFileA(<span class="literal">NULL</span>, URL地址, 保存文件名, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hr == S_OK)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"URL地址:%s     成功了\n"</span>, URL地址);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">printf_s(<span class="string">"URL地址:%s     偶哦，出错\n"</span>, URL地址);</span><br><span class="line"><span class="keyword">return</span> hr == S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明的全局变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> sy[<span class="number">20</span>] = <span class="string">"check.txt"</span>;<span class="comment">//保存的页面文件</span></span><br><span class="line"><span class="keyword">char</span> cNowTime[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">char</span> url[<span class="number">5000000</span>], bc[<span class="number">5000</span>];<span class="comment">//网页文件,保存文件名</span></span><br><span class="line"><span class="keyword">char</span> wd[<span class="number">5000</span>];<span class="comment">//图片地址</span></span><br><span class="line"><span class="built_in">string</span> folderPath;</span><br></pre></td></tr></table></figure><p>对于read</p><p>也就是想法的3,4,5</p><p>我们先把下载下来的页面文件存到url里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ifstream fsReader;</span><br><span class="line">fsReader.open(sy, ios::in);</span><br><span class="line"><span class="built_in">memset</span>(url, <span class="number">0</span>, <span class="keyword">sizeof</span>(url));</span><br><span class="line"><span class="keyword">while</span> (!fsReader.eof())</span><br><span class="line">&#123;</span><br><span class="line">    fsReader.getline(url+<span class="built_in">strlen</span>(url), <span class="number">5000000</span>);</span><br><span class="line">&#125;</span><br><span class="line">fsReader.close();</span><br></pre></td></tr></table></figure><p>通过文件读入，由于分隔符是空格，所以就一直读，直到没有为止</p><p>读入完就开始从头到尾遍历了</p><p>先声明几个循环变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, 记录 = <span class="number">0</span>, 计数 = <span class="number">0</span>,位置=<span class="number">0</span>,标记=<span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(url); i++)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是大模拟了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, 记录 = <span class="number">0</span>, 计数 = <span class="number">0</span>,位置=<span class="number">0</span>,标记=<span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(url); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (记录 == <span class="number">0</span> &amp;&amp; url[i] == <span class="string">'g'</span> &amp;&amp; url[i - <span class="number">1</span>] == <span class="string">'m'</span> &amp;&amp; url[i - <span class="number">2</span>] == <span class="string">'i'</span> &amp;&amp; url[i - <span class="number">3</span>] == <span class="string">'&lt;'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        记录 = <span class="number">1</span>;<span class="comment">//找到左边</span></span><br><span class="line">        标记 = i;<span class="comment">//特判点</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (记录 == <span class="number">1</span> &amp;&amp; url[i] == <span class="string">'='</span> &amp;&amp; url[i - <span class="number">1</span>] == <span class="string">'c'</span> &amp;&amp; url[i - <span class="number">2</span>] == <span class="string">'r'</span> &amp;&amp; url[i - <span class="number">3</span>] == <span class="string">'s'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        记录 = <span class="number">2</span>;<span class="comment">//左边找完</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (记录 == <span class="number">2</span> &amp;&amp; 计数 &lt;= <span class="number">2</span>)<span class="comment">//找地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (url[i] != <span class="string">'"'</span>)wd[<span class="built_in">strlen</span>(wd)] = url[i];</span><br><span class="line">        <span class="keyword">if</span> (url[i] == <span class="string">'"'</span>)计数++;</span><br><span class="line">        <span class="keyword">if</span> (url[i] == <span class="string">'/'</span>)位置 = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (记录 == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - 标记 &gt; <span class="number">1000</span>)<span class="comment">//特判，面得下到些奇奇怪怪的东西</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(bc, <span class="number">0</span>, <span class="keyword">sizeof</span>(bc));</span><br><span class="line">            <span class="built_in">memset</span>(wd, <span class="number">0</span>, <span class="keyword">sizeof</span>(wd));</span><br><span class="line">            记录 = <span class="number">0</span>;</span><br><span class="line">            计数 = <span class="number">0</span>;</span><br><span class="line">            位置 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (记录 == <span class="number">2</span> &amp;&amp; 计数 == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//bc[0] = '"';</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">strlen</span>(cNowTime); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            bc[<span class="built_in">strlen</span>(bc)] = cNowTime[j];</span><br><span class="line">        &#125;</span><br><span class="line">        bc[<span class="built_in">strlen</span>(bc)]=<span class="string">'\\'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = 位置 + <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (url[j] == <span class="string">'&gt;'</span> || url[j] == <span class="string">'&lt;'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(bc, <span class="number">0</span>, <span class="keyword">sizeof</span>(bc));</span><br><span class="line">                <span class="built_in">memset</span>(wd, <span class="number">0</span>, <span class="keyword">sizeof</span>(wd));</span><br><span class="line">                记录 = <span class="number">0</span>;</span><br><span class="line">                计数 = <span class="number">0</span>;</span><br><span class="line">                位置 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bc[<span class="built_in">strlen</span>(bc)] = url[j];</span><br><span class="line">        &#125;</span><br><span class="line">        downURL(wd, bc);</span><br><span class="line">        <span class="built_in">memset</span>(bc, <span class="number">0</span>, <span class="keyword">sizeof</span>(bc));</span><br><span class="line">        <span class="built_in">memset</span>(wd, <span class="number">0</span>, <span class="keyword">sizeof</span>(wd));</span><br><span class="line">        记录 = <span class="number">0</span>;</span><br><span class="line">        计数 = <span class="number">0</span>;</span><br><span class="line">        位置 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> sy[<span class="number">20</span>] = <span class="string">"check.txt"</span>;</span><br><span class="line"><span class="keyword">char</span> cNowTime[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">char</span> url[<span class="number">5000000</span>], bc[<span class="number">5000</span>];<span class="comment">//网页文件,保存文件名</span></span><br><span class="line"><span class="keyword">char</span> wd[<span class="number">5000</span>];<span class="comment">//图片地址</span></span><br><span class="line"><span class="built_in">string</span> folderPath;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">downURL</span><span class="params">(<span class="keyword">char</span> *URL地址,<span class="keyword">char</span> *保存文件名)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HRESULT hr = URLDownloadToFileA(<span class="literal">NULL</span>, URL地址, 保存文件名, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hr == S_OK)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"URL地址:%s     成功了\n"</span>, URL地址);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">printf_s(<span class="string">"URL地址:%s     偶哦，出错\n"</span>, URL地址);</span><br><span class="line"><span class="keyword">return</span> hr == S_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream fsReader;</span><br><span class="line">fsReader.open(sy, ios::in);</span><br><span class="line"><span class="built_in">memset</span>(url, <span class="number">0</span>, <span class="keyword">sizeof</span>(url));</span><br><span class="line"><span class="keyword">while</span> (!fsReader.eof())</span><br><span class="line">&#123;</span><br><span class="line">fsReader.getline(url+<span class="built_in">strlen</span>(url), <span class="number">5000000</span>);</span><br><span class="line">&#125;</span><br><span class="line">fsReader.close();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, 记录 = <span class="number">0</span>, 计数 = <span class="number">0</span>,位置=<span class="number">0</span>,标记=<span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(url); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (记录 == <span class="number">0</span> &amp;&amp; url[i] == <span class="string">'g'</span> &amp;&amp; url[i - <span class="number">1</span>] == <span class="string">'m'</span> &amp;&amp; url[i - <span class="number">2</span>] == <span class="string">'i'</span> &amp;&amp; url[i - <span class="number">3</span>] == <span class="string">'&lt;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">记录 = <span class="number">1</span>;<span class="comment">//找到左边</span></span><br><span class="line">标记 = i;<span class="comment">//特判点</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (记录 == <span class="number">1</span> &amp;&amp; url[i] == <span class="string">'='</span> &amp;&amp; url[i - <span class="number">1</span>] == <span class="string">'c'</span> &amp;&amp; url[i - <span class="number">2</span>] == <span class="string">'r'</span> &amp;&amp; url[i - <span class="number">3</span>] == <span class="string">'s'</span>)</span><br><span class="line">&#123;</span><br><span class="line">记录 = <span class="number">2</span>;<span class="comment">//左边找完</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (记录 == <span class="number">2</span> &amp;&amp; 计数 &lt;= <span class="number">2</span>)<span class="comment">//找地址</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (url[i] != <span class="string">'"'</span>)wd[<span class="built_in">strlen</span>(wd)] = url[i];</span><br><span class="line"><span class="keyword">if</span> (url[i] == <span class="string">'"'</span>)计数++;</span><br><span class="line"><span class="keyword">if</span> (url[i] == <span class="string">'/'</span>)位置 = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (记录 == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i - 标记 &gt; <span class="number">1000</span>)<span class="comment">//特判，面得下到些奇奇怪怪的东西</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(bc, <span class="number">0</span>, <span class="keyword">sizeof</span>(bc));</span><br><span class="line"><span class="built_in">memset</span>(wd, <span class="number">0</span>, <span class="keyword">sizeof</span>(wd));</span><br><span class="line">记录 = <span class="number">0</span>;</span><br><span class="line">计数 = <span class="number">0</span>;</span><br><span class="line">位置 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (记录 == <span class="number">2</span> &amp;&amp; 计数 == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//bc[0] = '"';</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">strlen</span>(cNowTime); j++)</span><br><span class="line">&#123;</span><br><span class="line">bc[<span class="built_in">strlen</span>(bc)] = cNowTime[j];</span><br><span class="line">&#125;</span><br><span class="line">bc[<span class="built_in">strlen</span>(bc)]=<span class="string">'\\'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = 位置 + <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (url[j] == <span class="string">'&gt;'</span> || url[j] == <span class="string">'&lt;'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(bc, <span class="number">0</span>, <span class="keyword">sizeof</span>(bc));</span><br><span class="line"><span class="built_in">memset</span>(wd, <span class="number">0</span>, <span class="keyword">sizeof</span>(wd));</span><br><span class="line">记录 = <span class="number">0</span>;</span><br><span class="line">计数 = <span class="number">0</span>;</span><br><span class="line">位置 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">bc[<span class="built_in">strlen</span>(bc)] = url[j];</span><br><span class="line">&#125;</span><br><span class="line">downURL(wd, bc);</span><br><span class="line"><span class="built_in">memset</span>(bc, <span class="number">0</span>, <span class="keyword">sizeof</span>(bc));</span><br><span class="line"><span class="built_in">memset</span>(wd, <span class="number">0</span>, <span class="keyword">sizeof</span>(wd));</span><br><span class="line">记录 = <span class="number">0</span>;</span><br><span class="line">计数 = <span class="number">0</span>;</span><br><span class="line">位置 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printf_s(<span class="string">"输入url地址："</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(url, <span class="number">0</span>, <span class="keyword">sizeof</span>(url));</span><br><span class="line"><span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">if</span> (s != <span class="string">'\n'</span>)url[<span class="number">0</span>] = s;<span class="comment">//略掉回车</span></span><br><span class="line">scanf_s(<span class="string">"%s"</span>, url + <span class="built_in">strlen</span>(url), <span class="keyword">sizeof</span>(url));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">t</span>;</span>   <span class="comment">//tm结构指针</span></span><br><span class="line"><span class="keyword">time_t</span> now;  <span class="comment">//声明time_t类型变量</span></span><br><span class="line">time(&amp;now);      <span class="comment">//获取系统日期和时间</span></span><br><span class="line">localtime_s(&amp;t, &amp;now);   <span class="comment">//获取当地日期和时间</span></span><br><span class="line">strftime(cNowTime, <span class="keyword">sizeof</span>(cNowTime), <span class="string">"%Y%m%d-%H%M%S"</span>, &amp;t);</span><br><span class="line">_mkdir(cNowTime);</span><br><span class="line">CreateDirectoryA(folderPath.c_str(), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (downURL(url, sy) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">read();</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">printf_s(<span class="string">"输入url地址："</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;direct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;UrlMon.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"urlmon.lib"</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>所需头文件</p><p>编译成功后输入url地址，开始下载，要保证输入的页面文件里面有img标签而不是图片在css里边</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/document/壁纸获取源码.rar&quot;&gt;下载源码&lt;/a&gt;     &lt;a href=&quot;/document/壁纸获取软件.rar&quot;&gt;下载工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码我是在VS2019上使用c++的控制台应用写的&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;大家都知道壁纸怎么下载，但是会有一种情况，一张页面上的壁纸非常多，下了半天才下完，我冥思苦想，想去找一个软件可以输入url地址就可以下载完那一页的壁纸。在网上找了找，基本我都用不了，于是考虑自己写一个。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="http://www.scwyl.cn/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="工具" scheme="http://www.scwyl.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>数论</title>
    <link href="http://www.scwyl.cn/2019/08/25/%E6%95%B0%E8%AE%BA/"/>
    <id>http://www.scwyl.cn/2019/08/25/数论/</id>
    <published>2019-08-24T19:00:00.000Z</published>
    <updated>2019-08-24T19:23:50.584Z</updated>
    
    <content type="html"><![CDATA[<p>数论是<a href="https://baike.baidu.com/item/纯粹数学" target="_blank" rel="noopener">纯粹数学</a>的分支之一，主要研究<a href="https://baike.baidu.com/item/整数" target="_blank" rel="noopener">整数</a>的性质。整数可以是方程式的解（<a href="https://baike.baidu.com/item/丢番图方程/5466939" target="_blank" rel="noopener">丢番图方程</a>）。有些<a href="https://baike.baidu.com/item/解析函数/2281833" target="_blank" rel="noopener">解析函数</a>（像<a href="https://baike.baidu.com/item/黎曼ζ函数" target="_blank" rel="noopener">黎曼ζ函数</a>）中包括了一些整数、质数的性质，透过这些函数也可以了解一些数论的问题。透过数论也可以建立实数和有理数之间的关系，并且用有理数来逼近实数（<a href="https://baike.baidu.com/item/丢番图逼近/10724965" target="_blank" rel="noopener">丢番图逼近</a>）。</p><p>按研究方法来看，数论大致可分为<a href="https://baike.baidu.com/item/初等数论/2375326" target="_blank" rel="noopener">初等数论</a>和高等数论。初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、<a href="https://baike.baidu.com/item/同余" target="_blank" rel="noopener">同余</a>理论、<a href="https://baike.baidu.com/item/连分数/2715871" target="_blank" rel="noopener">连分数</a>理论。高等数论则包括了更为深刻的数学研究工具。它大致包括<a href="https://baike.baidu.com/item/代数数论/5919796" target="_blank" rel="noopener">代数数论</a>、<a href="https://baike.baidu.com/item/解析数论/2281979" target="_blank" rel="noopener">解析数论</a>、<a href="https://baike.baidu.com/item/计算数论" target="_blank" rel="noopener">计算数论</a>等等。</p><p>———摘自百度百科</p><a id="more"></a><h3 id="目录"><a href="#目录" class="headerlink" title="目录:"></a>目录:</h3><p>1.素数判断(质数判断)<br>2.建立素数表（欧筛，线筛）<br>3.快速幂<br>4.慢乘<br>5.分解质因数<br>6.求最大公约数(gcd)<br>7.求最小公倍数(lcm)<br>8.扩展欧几里得（求线性同余方程）<br>9.扩展中国剩余定理<br>10.费马小定理<br>11.欧拉函数<br>12.欧拉定理(扩展欧拉定理)<br>13.卢卡斯定理(扩展卢卡斯定理)<br>14.高斯消元</p><p>​      互质       ——-若N个整数的最大公因数是1，则称这N个整数互质</p><p>​      合数       ——-指自然数中除了能被1和本身整除外，还能被其他数(0除外)整除的数。</p><p>素数即质数——-质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p><p>因数即约数——-因数是指整数a除以整数b(b≠0) 的商正好是整数而没有余数，我们就说b是a的因数。</p><h3 id="1-素数判断-质数判断"><a href="#1-素数判断-质数判断" class="headerlink" title="1.素数判断(质数判断)"></a>1.素数判断(质数判断)</h3><p>时间复杂度o(sqrt(n))</p><p>对于质数，质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p><p>知道这个限制，就很好判断了</p><p>让n去除以2到sqrt(n)的所有数，看看是否被整除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//要判断的n</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> sq</span>=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sq;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//被整除，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="2-建立素数表（欧筛，线筛）"><a href="#2-建立素数表（欧筛，线筛）" class="headerlink" title="2.建立素数表（欧筛，线筛）"></a>2.建立素数表（欧筛，线筛）</h3><p>例题      <a href="https://www.luogu.org/problem/P3383" target="_blank" rel="noopener">【模板】线性筛素数</a></p><p>欧筛是o(n),线筛是o(nloglogn)</p><h5 id="线筛"><a href="#线筛" class="headerlink" title="线筛"></a>线筛</h5><p>线筛又称埃拉托斯特尼筛法(埃筛)</p><p>具体操作如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dt[n];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//打出1-n的表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dt[i]==<span class="number">0</span>)<span class="comment">//当前数还没被筛过，即当前数是质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;i*j&lt;=n;j++)<span class="comment">//筛掉当前数的倍数</span></span><br><span class="line">            &#123;</span><br><span class="line">                dt[i*j]=<span class="number">1</span>;<span class="comment">//当前数的倍数一定不是质数</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dt[i]==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以1-100为例，如图,白色为dt==0,黄色为dt==1</p><p><img src="/images/数论1.png" alt></p><p>我们从2开始,把2的倍数打上标记</p><p><img src="/images/数论2.png" alt></p><p>再把下一个白色的倍数打上标记，即把3的倍数打上标记</p><p><img src="/images/数论3.png" alt></p><p>如此反复，知道最后一个</p><p><img src="/images/数论4.png" alt></p><p>如此剩下的白色除1以外就是质数了</p><h5 id="欧筛"><a href="#欧筛" class="headerlink" title="欧筛"></a>欧筛</h5><p>看到上边的线筛，会发现，一个数会被多次筛掉，如10,它会被2和5同时筛掉。</p><p>欧筛就是在这基础上，筛掉质数倍，举例</p><p>循环到5的时候，之前的质数是2和3，那就筛掉5的2倍和3倍，以此类推</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[n],len,user[n];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(user[i]==<span class="number">0</span>)prime[++len]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;n)<span class="keyword">break</span>;</span><br><span class="line">            u[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一种方法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(user[i]==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二种方法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,prime[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于prime数组的大小，其实可以缩小点，</p><p>质数密度(x以内最多有多少质数)：x/ln(x)或[x/lg2(x)1.3]或[x/lg2(x)1.5]；</p><p>利用质数密度就可以节省prime数组的空间</p><h3 id="3-快速幂"><a href="#3-快速幂" class="headerlink" title="3.快速幂"></a>3.快速幂</h3><p>例题     <a href="https://www.luogu.org/problem/P1226" target="_blank" rel="noopener">【模板】快速幂||取余运算</a></p><p>时间复杂度 o(logn)</p><p>我们知道对与<script type="math/tex">n^x</script>我们可以用<script type="math/tex">n^{x/2}*n^{x/2}</script>来得到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x,<span class="keyword">int</span> mod)</span><span class="comment">//计算n^x % mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>)ans=(ans*n)%mod;</span><br><span class="line">        n*=n;</span><br><span class="line">        x/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-慢乘"><a href="#4-慢乘" class="headerlink" title="4.慢乘"></a>4.慢乘</h3><p>同快速幂一个道理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> mod)</span><span class="comment">//计算a*b % mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)ans=(ans+a)%mod;</span><br><span class="line">        a/=<span class="number">2</span>;</span><br><span class="line">        b*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-分解质因数"><a href="#5-分解质因数" class="headerlink" title="5.分解质因数"></a>5.分解质因数</h3><p>对于分解质因数，我们把一个数不停的mod 质数，在为0的情况下这个质数就是这个数的因数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//把n分解质因数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)        </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n=n/i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(n!=<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>,n);        <span class="comment">//当n为质数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-求最大公约数-gcd"><a href="#6-求最大公约数-gcd" class="headerlink" title="6.求最大公约数(gcd)"></a>6.求最大公约数(gcd)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//辗转相除法（欧几里德算法）求最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-求最小公倍数-lcm"><a href="#7-求最小公倍数-lcm" class="headerlink" title="7.求最小公倍数(lcm)"></a>7.求最小公倍数(lcm)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b/gcd(a,b);<span class="comment">//最小公倍数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-扩展欧几里得（求线性同余方程）"><a href="#8-扩展欧几里得（求线性同余方程）" class="headerlink" title="8.扩展欧几里得（求线性同余方程）"></a>8.扩展欧几里得（求线性同余方程）</h3><p>线性同余方程即<script type="math/tex">(a*x+b*y=c)</script>,告诉a,b,c,求x,y;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> &amp;d,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//d为a,b的最大公约数即(gcd(a,b))</span></span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d=a;</span><br><span class="line">x=c/a;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x1,y1;</span><br><span class="line">ex_gcd(b,a%b,d,x1,y1);</span><br><span class="line">x=y1;</span><br><span class="line">y=x1-(a/b)*y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面这个函数之后,得到的d为a,b的最大公约数即(gcd(a,b))</p><p>得到的x,y为一组特殊解</p><p>如果要得到最小整数解或者最大负数解，可以在此基础上更改</p><p>x的通解<script type="math/tex">x+K*b/gcd(a,b);</script>即<script type="math/tex">x+K*(b/d)</script><br>y的通解<script type="math/tex">y+K*a/gcd(a,b);</script>即<script type="math/tex">y+K*(a/d)</script></p><script type="math/tex; mode=display">K∈[-∞,+∞],K∈Z</script><h5 id="扩欧求逆元"><a href="#扩欧求逆元" class="headerlink" title="扩欧求逆元"></a>扩欧求逆元</h5><p>如果有 a*x%m=1 则x为a的逆元</p><p>转换为<script type="math/tex">a*x+b*m=1</script>,求出x，b即可</p><p>然后让(x+m)%m就是最小的逆元了</p><h5 id="求1-N所有整数的逆元-p-且p是质数"><a href="#求1-N所有整数的逆元-p-且p是质数" class="headerlink" title="求1-N所有整数的逆元(%p)且p是质数"></a>求1-N所有整数的逆元(%p)且p是质数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)inv[i]=(p-p/i)*inv[p%i]%p;</span><br></pre></td></tr></table></figure><h3 id="9-扩展中国剩余定理"><a href="#9-扩展中国剩余定理" class="headerlink" title="9.扩展中国剩余定理"></a>9.扩展中国剩余定理</h3><p>例题<a href="https://www.luogu.org/problem/P4777" target="_blank" rel="noopener">扩展中国剩余定理（EXCRT）</a></p><p>扩展中国剩余定理是用来解线性同余方程组的</p><script type="math/tex; mode=display">\begin{cases}    x≡b_1(mod\ a_1)\\    x≡b_2(mod\ a_2)\\    x≡b_3(mod\ a_3)\\    x≡b_4(mod\ a_4)\\    ...\\    x≡b_n(mod\ a_n)\\\end{cases}</script><p>假设已经求出前n-1个方程组成的同余方程组的一个解为x</p><p>M为<script type="math/tex">LCM(m_1,m_2,m_3,m_4,...,m_{n-1})</script></p><p>则前n-1个方程的方程组通解为<script type="math/tex">x+i∗M,(i∈Z)</script></p><p>对于加入第n个方程后的方程组,需要找一个正整数H让<script type="math/tex">x+H∗M≡a_n(mod\ m_n)</script></p><p>转化一下得到 <script type="math/tex">H∗M≡a_n−x(mod\ m_n)</script></p><p>对于这个式子我们已经可以通过扩展欧几里得求解H</p><p>若该同余式无解，则整个方程组无解， 若有，则前k个同余式组成的方程组的一个解为<script type="math/tex">x_n=x+H∗M</script></p><p>会用到之前的扩展欧几里得和慢乘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> mod)</span><span class="comment">//计算a*b % mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)ans=(ans+a)%mod;</span><br><span class="line">        a/=<span class="number">2</span>;</span><br><span class="line">        b*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> &amp;d,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//d为a,b的最大公约数即(gcd(a,b))</span></span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d=a;</span><br><span class="line">x=c/a;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x1,y1;</span><br><span class="line">ex_gcd(b,a%b,d,x1,y1);</span><br><span class="line">x=y1;</span><br><span class="line">y=x1-(a/b)*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_crt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,k;</span><br><span class="line">    <span class="keyword">int</span> M=an[<span class="number">1</span>],ans=bn[<span class="number">1</span>];<span class="comment">//第一个方程的解特判</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> gcd=<span class="number">0</span>,a=M,b=an[i],c=((bn[i]-ans)%b+b)%b;<span class="comment">//ax≡c(mod b)</span></span><br><span class="line">        exgcd(a,b,a,gcd,x,y),bg=b/gcd;</span><br><span class="line">        <span class="keyword">if</span>(c%gcd!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断是否无解</span></span><br><span class="line">        x=mc(x,c/gcd,bg);</span><br><span class="line">        ans+=x*M;<span class="comment">//更新前k个方程组的答案</span></span><br><span class="line">        M*=bg;<span class="comment">//M为前k个m的最小公倍数(lcm)</span></span><br><span class="line">        ans=(ans%M+M)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans%M+M)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后ex_crt返回的就是最小非负整数解</p><h3 id="10-费马小定理"><a href="#10-费马小定理" class="headerlink" title="10.费马小定理"></a>10.费马小定理</h3><script type="math/tex; mode=display">若p为素数， gcd(a, p) = 1, 则a^{p−1}≡1(mod\ p)</script><h5 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><span class="comment">//a为要求的逆元，b为mod-2的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)c = c*a%mod;</span><br><span class="line">        a = a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算<script type="math/tex">n^xmod\ z</script></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x,<span class="keyword">int</span> mod)</span><span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>)ans=(ans*n)%mod;</span><br><span class="line">        n*=n;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fm</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x,<span class="keyword">int</span> z)</span><span class="comment">//费马</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x%(z<span class="number">-1</span>)==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ksm(n,x%(z<span class="number">-1</span>),z); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-欧拉函数"><a href="#11-欧拉函数" class="headerlink" title="11.欧拉函数"></a>11.欧拉函数</h3><p>正整数n，欧拉函数(φ函数)是小于或等于n的正整数中与n互质的数的数目φ(1)=1</p><p>通式：<script type="math/tex">φ(x)=x(1-1/p_1)(1-1/p_2)(1-1/p_3)(1-1/p_4)…..(1-1/p_n)</script>,其中<script type="math/tex">p_1, p_2……p_n</script>为x的所有质因数</p><p>注意：每种质因数只一个。比如<script type="math/tex">12=2*2*3</script>那么<script type="math/tex">φ（12）=12*（1-1/2）*(1-1/3)=4</script></p><p>推论：</p><p>当n为奇数时，有<script type="math/tex">φ(2n)=φ(n)</script>。</p><p>若n是质数p的k次幂，则<script type="math/tex">φ(n)=p^k-p^{(k-1)}=(p-1)*p^{(k-1)}</script>，因为除了p的倍数外，其他数都跟n互质。</p><p>欧拉函数是积性函数——若gcd(m,n)==1互质，则<script type="math/tex">φ(m*n)=φ(m)*φ(n)</script>。</p><p>o(sqrt(n))​ 求欧拉函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oula</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//求x的欧拉函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=x,sq=<span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=sq; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans - ans / i;</span><br><span class="line">        <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) ans = ans * (x<span class="number">-1</span>) / x;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化:先把50 000以内的素数用筛选法选出来并保存，以方便欧拉函数使用</p><p>复杂度为O（x），x为 $sqrt(n)$ 以内素数的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[n],len,user[n];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(user[i]==<span class="number">0</span>)prime[++len]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;n)<span class="keyword">break</span>;</span><br><span class="line">            u[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oula</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; prime[i]*prime[i]&lt;=n&amp;&amp;prime[i]!=<span class="number">0</span>; i++)<span class="comment">//对于一些不是素数的可不遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%p[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=ans-ans/n;</span><br><span class="line">            <span class="keyword">while</span>(n%p[i]==<span class="number">0</span>)n/=p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)ans=ans-ans/n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用欧拉函数过多，可以用递推实现求欧拉函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)p[i]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n; i+=<span class="number">2</span>)p[i]/=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>; i&lt;=n; i+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i]==i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i; j&lt;=n; j+=i)p[j]=p[j]/i*(i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p[i]便是i的欧拉函数</p><h3 id="12-欧拉定理-扩展欧拉定理"><a href="#12-欧拉定理-扩展欧拉定理" class="headerlink" title="12.欧拉定理(扩展欧拉定理)"></a>12.欧拉定理(扩展欧拉定理)</h3><p>例题<a href="https://www.luogu.org/problem/P5091" target="_blank" rel="noopener">【模板】欧拉定理</a></p><p>欧拉定理:a与 m 互质时，$a^{φ(m)}≡1\ mod\ m$。</p><p>扩展欧拉定理:无需 a,m互质。$b≥φ(m)时,a^b≡a^{(b\ mod\ φ(m))+φ(m)}mod\ m$。</p><p>扩展欧拉定理代码</p><p>求$a^bmod\ m$</p><p>由于b通常很大，先用s数组存起来，然后对m的欧拉函数取模</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,m,H;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oula</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//求m的欧拉函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=x,sq=<span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=sq; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans - ans / i;</span><br><span class="line">        <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) ans = ans * (x<span class="number">-1</span>) / x;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S_b</span><span class="params">()</span><span class="comment">//转换,与快读类似</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">bool</span> f=<span class="number">0</span>,l=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(s[i]^<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;=H)f=<span class="number">1</span>;</span><br><span class="line">        ans%=H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)ans+=H;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x,<span class="keyword">int</span> mod)</span><span class="comment">//计算n^x % mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>)ans=(ans*n)%mod;</span><br><span class="line">        n*=n;</span><br><span class="line">        x/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>,&amp;a,&amp;m,&amp;s);</span><br><span class="line">    H=oula(m);</span><br><span class="line">    b=S_b();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ksm(a%m,b,m));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-卢卡斯定理-扩展卢卡斯定理"><a href="#13-卢卡斯定理-扩展卢卡斯定理" class="headerlink" title="13.卢卡斯定理(扩展卢卡斯定理)"></a>13.卢卡斯定理(扩展卢卡斯定理)</h3><p>C(n,m)即n个中选m个的方案数也可以写成$C\tbinom{m}{n}$</p><p>普通计算公式$C\tbinom{m}{n}=\frac{n!}{m!(n-m)!}$</p><p>当n,m很小时直接算没有什么问题，$C(n,m)=n<em>(n-1)</em>…*(n-m+1)/m!$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=(n-m+<span class="number">1</span>); --i) ans *= i; </span><br><span class="line">    <span class="keyword">while</span>(m) ans /= m--; </span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是n,m稍微大一点点，时间空间直接炸掉。</p><p>可以根据递推公式递推，$C(n,m)=C(n-1,m-1)+C(n-1,m)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=MAXN; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        C[<span class="number">0</span>][i] = <span class="number">0</span>; </span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=MAXN; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=MAXN; ++j) </span><br><span class="line">            C[i][j] = C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> C[n][m]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而题目当中很多时候都会让你对一个数取模，</p><p>对于那个数是质数，我们可以用卢卡斯定理解决</p><p>$C(n,m)\%\ p=C(n/p,m/p)*C(n\%\ p,m\%\ p)\%\ p,p为素数$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x,<span class="keyword">int</span> mod)</span><span class="comment">//计算n^x % mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>)ans=(ans*n)%mod;</span><br><span class="line">        n*=n;</span><br><span class="line">        x/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n - m) m = n - m;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>, cn = <span class="number">1</span>, cm = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        cn = cn * (n - i) % p;</span><br><span class="line">        cm = cm * (m - i) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = cn * ksm(cm, p - <span class="number">2</span>, p) % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> p)</span><span class="comment">//n个取m个对p取模</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &amp;&amp; m) </span><br><span class="line">    &#123;</span><br><span class="line">        ans = (ans * C(n % p, m % p, p)) % p;</span><br><span class="line">        n /= p;</span><br><span class="line">        m /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当p不是质数怎么办，</p><p>没事，拓展卢卡斯就可以在p不是质数的情况下使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> &amp;d,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d=a;</span><br><span class="line">x=c/a;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x1,y1;</span><br><span class="line">ex_gcd(b,a%b,d,x1,y1);</span><br><span class="line">x=y1;</span><br><span class="line">y=x1-(a/b)*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x,<span class="keyword">int</span> mod)</span><span class="comment">//计算n^x % mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>)ans=(ans*n)%mod;</span><br><span class="line">        n*=n;</span><br><span class="line">        x/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> pi,<span class="keyword">int</span> pk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=pk;++i)<span class="keyword">if</span>(i%pi)res=(res*i)%pk;</span><br><span class="line">    res=power(res,n/pk,pk);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n%pk;++i)<span class="keyword">if</span>(i%pi)res=(res*i)%pk;</span><br><span class="line">    <span class="keyword">return</span> res*fac(n/pi,pi,pk)%pk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,d;</span><br><span class="line">    ex_gcd(n,mod,n,d,x,y)</span><br><span class="line">    x+=mod;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;mod)<span class="keyword">return</span> x-mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> b,<span class="keyword">int</span> mod)</span></span>&#123;<span class="keyword">return</span> b*inv(p/mod,mod)%p*(p/mod)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> pi,<span class="keyword">int</span> pk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> up=fac(n,pi,pk),d1=fac(m,pi,pk),d2=fac(n-m,pi,pk);</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i/=pi)k+=i/pi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i;i/=pi)k-=i/pi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n-m;i;i/=pi)k-=i/pi;</span><br><span class="line">    <span class="keyword">return</span> up*inv(d1,pk)%pk*inv(d2,pk)%pk*ksm(pi,k,pk)%pk;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exlucus</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,tmp=p,pk,sq=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sq;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pk=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp%i==<span class="number">0</span>)pk*=i,tmp/=i;</span><br><span class="line">            ans=(ans+CRT(C(n,m,i,pk),pk))%p;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)ans=(ans+CRT(C(n,m,tmp,tmp),tmp))%=p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-高斯消元"><a href="#14-高斯消元" class="headerlink" title="14.高斯消元"></a>14.高斯消元</h3><p>——————————-待补充</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数论是&lt;a href=&quot;https://baike.baidu.com/item/纯粹数学&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纯粹数学&lt;/a&gt;的分支之一，主要研究&lt;a href=&quot;https://baike.baidu.com/item/整数&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;整数&lt;/a&gt;的性质。整数可以是方程式的解（&lt;a href=&quot;https://baike.baidu.com/item/丢番图方程/5466939&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;丢番图方程&lt;/a&gt;）。有些&lt;a href=&quot;https://baike.baidu.com/item/解析函数/2281833&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解析函数&lt;/a&gt;（像&lt;a href=&quot;https://baike.baidu.com/item/黎曼ζ函数&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黎曼ζ函数&lt;/a&gt;）中包括了一些整数、质数的性质，透过这些函数也可以了解一些数论的问题。透过数论也可以建立实数和有理数之间的关系，并且用有理数来逼近实数（&lt;a href=&quot;https://baike.baidu.com/item/丢番图逼近/10724965&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;丢番图逼近&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;按研究方法来看，数论大致可分为&lt;a href=&quot;https://baike.baidu.com/item/初等数论/2375326&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;初等数论&lt;/a&gt;和高等数论。初等数论是用初等方法研究的数论，它的研究方法本质上说，就是利用整数环的整除性质，主要包括整除理论、&lt;a href=&quot;https://baike.baidu.com/item/同余&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;同余&lt;/a&gt;理论、&lt;a href=&quot;https://baike.baidu.com/item/连分数/2715871&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;连分数&lt;/a&gt;理论。高等数论则包括了更为深刻的数学研究工具。它大致包括&lt;a href=&quot;https://baike.baidu.com/item/代数数论/5919796&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代数数论&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/解析数论/2281979&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解析数论&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/计算数论&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算数论&lt;/a&gt;等等。&lt;/p&gt;
&lt;p&gt;———摘自百度百科&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://www.scwyl.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>贪吃蛇</title>
    <link href="http://www.scwyl.cn/2019/08/18/%E8%B4%AA%E5%90%83%E8%9B%87/"/>
    <id>http://www.scwyl.cn/2019/08/18/贪吃蛇/</id>
    <published>2019-08-18T10:30:00.000Z</published>
    <updated>2019-08-19T03:15:45.077Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/document/TCS源码.rar">下载源码</a>     <a href="/document/TCS软件.rar">下载游戏</a></p><p>源码我是在VS2019上使用c++的控制台应用写的</p><a id="more"></a><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>1.需要蛇，食物，边界判断，还有分数<br>2.观察贪吃蛇游戏，对于蛇的移动只有把脑袋往前移和拆掉尾巴，所以不使用system(“cls”);<br>3.食物，吃完一个就马上随机新一个的位置<br>4.达到边界就判断失败<br>5.每吃一个就有得分<br>6.吃了一定数目，就加速，分值增加</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>先建立几个变量<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Game = <span class="literal">true</span>;<span class="comment">//在没在游戏中</span></span><br><span class="line"><span class="keyword">bool</span> Over = <span class="literal">false</span>;<span class="comment">//死没死</span></span><br><span class="line"><span class="keyword">int</span> Score;<span class="comment">//当前分数</span></span><br><span class="line">HANDLE hOut= GetStdHandle(STD_OUTPUT_HANDLE);<span class="comment">//定义句柄</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pos</span><span class="params">(<span class="keyword">short</span> x, <span class="keyword">short</span> y)</span><span class="comment">//移动光标在(x,y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">COORD pos = &#123; x,y &#125;;</span><br><span class="line">SetConsoleCursorPosition(hOut, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>游戏初始化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span><span class="comment">//游戏初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CONSOLE_CURSOR_INFO s = &#123;<span class="number">1</span>,<span class="literal">true</span>&#125;;<span class="comment">//设置光标大小，隐藏光标</span></span><br><span class="line">SetConsoleCursorInfo(hOut, &amp;s);</span><br><span class="line">SetConsoleTitleA(<span class="string">"贪吃蛇0.2"</span>);<span class="comment">//设置控制台标题</span></span><br><span class="line">system(<span class="string">"cls"</span>);<span class="comment">//清屏</span></span><br><span class="line">pos(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (SHORT i = <span class="number">1</span>; i &lt;= <span class="number">23</span>; i++)<span class="built_in">cout</span> &lt;&lt; <span class="string">"■"</span>;<span class="comment">//上</span></span><br><span class="line">pos(<span class="number">3</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">for</span> (SHORT i = <span class="number">1</span>; i &lt;= <span class="number">23</span>; i++)<span class="built_in">cout</span> &lt;&lt; <span class="string">"■"</span>;<span class="comment">//下</span></span><br><span class="line"><span class="keyword">for</span> (SHORT i = <span class="number">1</span>; i &lt;= <span class="number">25</span>; i++)pos(<span class="number">0</span>, i),<span class="built_in">cout</span> &lt;&lt; <span class="string">" ■"</span>;<span class="comment">//左</span></span><br><span class="line"><span class="keyword">for</span> (SHORT i = <span class="number">1</span>; i &lt;= <span class="number">25</span>; i++)pos(<span class="number">47</span>, i),<span class="built_in">cout</span> &lt;&lt; <span class="string">"■"</span>;<span class="comment">//右</span></span><br><span class="line">pos(<span class="number">3</span> + <span class="number">51</span>, <span class="number">3</span> + <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"■操作说明："</span>;</span><br><span class="line">pos(<span class="number">3</span> + <span class="number">51</span>, <span class="number">3</span> + <span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"■向上移动：↑ W"</span>;</span><br><span class="line">pos(<span class="number">3</span> + <span class="number">51</span>, <span class="number">3</span> + <span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"■向下移动：↓ S"</span>;</span><br><span class="line">pos(<span class="number">3</span> + <span class="number">51</span>, <span class="number">3</span> + <span class="number">6</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"■向左移动：← A"</span>;</span><br><span class="line">pos(<span class="number">3</span> + <span class="number">51</span>, <span class="number">3</span> + <span class="number">7</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"■向右移动：→ D"</span>;</span><br><span class="line">pos(<span class="number">3</span> + <span class="number">51</span>, <span class="number">3</span> + <span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"■暂停游戏：空格"</span>;</span><br><span class="line">pos(<span class="number">3</span> + <span class="number">51</span>, <span class="number">3</span> + <span class="number">9</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"■开始游戏：任意方向键"</span>;</span><br><span class="line">writescore();</span><br><span class="line">傻不拉几.cls();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>游戏结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gameover</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">system(<span class="string">"cls"</span>);<span class="comment">//清屏</span></span><br><span class="line">pos(<span class="number">17</span>, <span class="number">11</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"游戏结束!"</span>;</span><br><span class="line">pos(<span class="number">15</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Y重新开始/N退出"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写分数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writescore</span><span class="params">()</span><span class="comment">//写分数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pos(<span class="number">3</span> + <span class="number">51</span>, <span class="number">3</span> + <span class="number">14</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"■ 当前得分： "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蛇</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">deque</span>&lt;COORD&gt;body;<span class="comment">//傻不拉几的身体</span></span><br><span class="line"><span class="comment">//deque.pop_front()//去掉尾巴</span></span><br><span class="line"><span class="comment">//deque.push_back()//向前一步</span></span><br><span class="line"><span class="comment">//back是头</span></span><br><span class="line"><span class="keyword">int</span> len, speed, eatfood, orientate;<span class="comment">//长度，速度，计数，方向:1上,2下,3左,4右</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (y &lt;= <span class="number">2</span> || y &gt;= <span class="number">24</span> || x &lt;= <span class="number">3</span> || x &gt;= <span class="number">46</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; body.size() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x == body.at(i).X &amp;&amp; y == body.at(i).Y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfood</span><span class="params">()</span><span class="comment">//新建食物</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="number">0</span>) + rand() % (<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">4</span> + rand() % <span class="number">27</span>;</span><br><span class="line">y = <span class="number">3</span> + rand() % <span class="number">27</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (x%<span class="number">2</span>!=<span class="number">1</span>||check());</span><br><span class="line">pos(x, y);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"食"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">orientate = <span class="number">1</span>;<span class="comment">//向上</span></span><br><span class="line">body.clear();</span><br><span class="line">COORD f1 = &#123; <span class="number">25</span>,<span class="number">13</span> &#125;;</span><br><span class="line">body.push_back(f1);</span><br><span class="line">len = <span class="number">1</span>, eatfood = <span class="number">0</span>, speed = <span class="number">3</span>;</span><br><span class="line">pos(body.back().X, body.back().Y);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"●"</span>;</span><br><span class="line">getfood();</span><br><span class="line">&#125;</span><br><span class="line">snack()</span><br><span class="line">&#123;</span><br><span class="line">cls();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_map</span><span class="params">()</span><span class="comment">//检测撞没撞到边或者自己</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//撞没撞到墙</span></span><br><span class="line"><span class="keyword">if</span> (body.back().Y &lt; <span class="number">2</span> || body.back().Y &gt; <span class="number">24</span> || body.back().X &lt; <span class="number">3</span> || body.back().X &gt; <span class="number">46</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; body.size()<span class="number">-1</span>; i++)<span class="comment">//撞没撞到自己</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (body.at(body.size()<span class="number">-1</span>).X == body.at(i).X &amp;&amp; body.at(body.size() - <span class="number">1</span>).Y == body.at(i).Y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_food</span><span class="params">()</span><span class="comment">//检测撞没撞到食物</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (body.at(body.size() - <span class="number">1</span>).X == x &amp;&amp; body.at(body.size() - <span class="number">1</span>).Y == y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (++len % <span class="number">11</span> == <span class="number">0</span>)gogogo();</span><br><span class="line">eatfood++;</span><br><span class="line">getfood();</span><br><span class="line">Score+=speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span><span class="comment">//蛇移动</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (orientate == <span class="number">1</span>)body.push_back(&#123; body.back().X,body.back().Y - <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">if</span> (orientate == <span class="number">2</span>)body.push_back(&#123; body.back().X,body.back().Y + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">if</span> (orientate == <span class="number">3</span>)body.push_back(&#123; body.back().X - <span class="number">2</span>,body.back().Y &#125;);</span><br><span class="line"><span class="keyword">if</span> (orientate == <span class="number">4</span>)body.push_back(&#123; body.back().X + <span class="number">2</span>,body.back().Y &#125;);</span><br><span class="line"><span class="keyword">if</span> (eatfood &gt; <span class="number">0</span>)eatfood--;<span class="comment">//这次移动不删除尾巴</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pos(body.front().X,body.front().Y);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">body.pop_front();</span><br><span class="line">&#125;</span><br><span class="line">check_food();</span><br><span class="line"><span class="keyword">if</span>(check_map() == <span class="number">1</span>)Over=<span class="literal">true</span>;</span><br><span class="line">pos(body.back().X, body.back().Y);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"●"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gogogo</span><span class="params">()</span></span>&#123;<span class="keyword">if</span> (speed &lt;<span class="number">10</span>)speed++;&#125;<span class="comment">//蛇加速</span></span><br><span class="line"></span><br><span class="line">&#125;傻不拉几;<span class="comment">//建立蛇</span></span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (Game)</span><br><span class="line">&#123;</span><br><span class="line">go();</span><br><span class="line">getch();</span><br><span class="line"><span class="keyword">while</span> (!Over)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_kbhit())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> s = getch();</span><br><span class="line"><span class="keyword">if</span> ((s == <span class="string">'W'</span> || s == <span class="string">'w'</span>) &amp;&amp; 傻不拉几.orientate != <span class="number">2</span>)傻不拉几.orientate = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((s == <span class="string">'S'</span> || s == <span class="string">'s'</span>) &amp;&amp; 傻不拉几.orientate != <span class="number">1</span>)傻不拉几.orientate = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> ((s == <span class="string">'A'</span> || s == <span class="string">'a'</span>) &amp;&amp; 傻不拉几.orientate != <span class="number">4</span>)傻不拉几.orientate = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> ((s == <span class="string">'D'</span> || s == <span class="string">'d'</span>) &amp;&amp; 傻不拉几.orientate != <span class="number">3</span>)傻不拉几.orientate = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">s = getch();</span><br><span class="line">&#125; <span class="keyword">while</span> (s != <span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">傻不拉几.get();</span><br><span class="line">writescore();</span><br><span class="line">Sleep(<span class="number">1000</span> / 傻不拉几.speed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (Over)</span><br><span class="line">&#123;</span><br><span class="line">gameover();</span><br><span class="line"><span class="keyword">char</span> s = getch();</span><br><span class="line"><span class="keyword">if</span> (s != <span class="string">'Y'</span> &amp;&amp; s != <span class="string">'y'</span> &amp;&amp; s != <span class="string">'N'</span> &amp;&amp; s != <span class="string">'n'</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">'Y'</span> || s == <span class="string">'y'</span>)</span><br><span class="line">&#123;</span><br><span class="line">Over = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">'N'</span> || s == <span class="string">'n'</span>)</span><br><span class="line">&#123;</span><br><span class="line">Game = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果出现C4996的警告，不需要管，在头文件上边加入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/document/TCS源码.rar&quot;&gt;下载源码&lt;/a&gt;     &lt;a href=&quot;/document/TCS软件.rar&quot;&gt;下载游戏&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码我是在VS2019上使用c++的控制台应用写的&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="http://www.scwyl.cn/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="游戏" scheme="http://www.scwyl.cn/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>费用流</title>
    <link href="http://www.scwyl.cn/2019/08/13/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>http://www.scwyl.cn/2019/08/13/费用流/</id>
    <published>2019-08-13T15:30:00.000Z</published>
    <updated>2019-08-13T15:48:43.639Z</updated>
    
    <content type="html"><![CDATA[<p>费用流是在最大流的基础上求出费用，满足费用最大或最小</p><a id="more"></a><p>由于是求费用，而费用相同的路流量会不一样，所以这里用EK算法</p><p><a href="https://www.luogu.org/problem/P3381" target="_blank" rel="noopener">最小费用最大流</a></p><p>看题，二话不说先敲个EK上去</p><p>但是怎么建图，根据最大流，会有一个流量为0的反向边供程序‘反悔’，那么怎么使反悔那部分和之前那部分的费用抵消，我们建反向边的时候就把费用设置成正向的相反数，这样一正一反就抵消了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> next,to,v,w;&#125;e[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> ansa,ansb;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">int</span> ei=<span class="number">1</span>,head[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[++ei].v=v;</span><br><span class="line">e[ei].next=head[x];</span><br><span class="line">e[ei].to=y;</span><br><span class="line">e[ei].w=w;</span><br><span class="line">head[x]=ei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x=<span class="number">0</span>;<span class="keyword">register</span> <span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read();m=read();S=read();T=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w,f;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">u=read();v=read();w=read();f=read();</span><br><span class="line">add(u,v,w,f);</span><br><span class="line">add(v,u,<span class="number">0</span>,-f);</span><br><span class="line">&#125;</span><br><span class="line">EK();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,ansa,ansb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么EK我们怎么写呢，还是按照之前没费用的一样，由于之前是求从S到T最短的，这里就把最短改为最便宜的或者最贵的，其他的不变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> next=T;</span><br><span class="line"><span class="keyword">while</span>(fa[next]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e[id[next]].v-=mn[T];</span><br><span class="line">e[id[next]^<span class="number">1</span>].v+=mn[T];</span><br><span class="line">next=fa[next];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(bfs())</span><br><span class="line">&#123;</span><br><span class="line">update();</span><br><span class="line">ansb+=dis[T]*mn[T];</span><br><span class="line">ansa+=mn[T];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要变的只有bfs部分</p><div class="table-container"><table><thead><tr><th>变量名</th><th>变量作用</th></tr></thead><tbody><tr><td>dis[i]</td><td>到达i时的最小费用</td></tr><tr><td>mn[i]</td><td>到达i时的流量</td></tr><tr><td>fa[i]</td><td>在最小费用路中的父节点</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qu;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">memset</span>(mn,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(mn));</span><br><span class="line"><span class="built_in">memset</span>(id,<span class="number">0</span>,<span class="keyword">sizeof</span>(id));</span><br><span class="line">dis[S]=<span class="number">0</span>;</span><br><span class="line">fa[S]=<span class="number">0</span>;</span><br><span class="line">qu.push(S);</span><br><span class="line"><span class="keyword">while</span>(!qu.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=qu.front();</span><br><span class="line">qu.pop();</span><br><span class="line">user[f1]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(e[i].v==<span class="number">0</span>||dis[t]&lt;=dis[f1]+e[i].w)<span class="keyword">continue</span>;</span><br><span class="line">dis[t]=dis[f1]+e[i].w;</span><br><span class="line">id[t]=i;</span><br><span class="line">fa[t]=f1;</span><br><span class="line">mn[t]=min(mn[f1],e[i].v);</span><br><span class="line"><span class="keyword">if</span>(user[t]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">qu.push(t);</span><br><span class="line">user[t]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[T]!=<span class="number">0x7f7f7f7f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是整合的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> next,to,v,w;&#125;e[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">5005</span>],fa[<span class="number">5005</span>],mn[<span class="number">5005</span>],user[<span class="number">5005</span>],id[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">int</span> ansa,ansb;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="keyword">int</span> ei=<span class="number">1</span>,head[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[++ei].v=v;</span><br><span class="line">e[ei].next=head[x];</span><br><span class="line">e[ei].to=y;</span><br><span class="line">e[ei].w=w;</span><br><span class="line">head[x]=ei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x=<span class="number">0</span>;<span class="keyword">register</span> <span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qu;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">memset</span>(mn,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(mn));</span><br><span class="line"><span class="built_in">memset</span>(id,<span class="number">0</span>,<span class="keyword">sizeof</span>(id));</span><br><span class="line">dis[S]=<span class="number">0</span>;</span><br><span class="line">fa[S]=<span class="number">0</span>;</span><br><span class="line">qu.push(S);</span><br><span class="line"><span class="keyword">while</span>(!qu.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=qu.front();</span><br><span class="line">qu.pop();</span><br><span class="line">user[f1]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(e[i].v==<span class="number">0</span>||dis[t]&lt;=dis[f1]+e[i].w)<span class="keyword">continue</span>;</span><br><span class="line">dis[t]=dis[f1]+e[i].w;</span><br><span class="line">id[t]=i;</span><br><span class="line">fa[t]=f1;</span><br><span class="line">mn[t]=min(mn[f1],e[i].v);</span><br><span class="line"><span class="keyword">if</span>(user[t]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">qu.push(t);</span><br><span class="line">user[t]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[T]!=<span class="number">0x7f7f7f7f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> next=T;</span><br><span class="line"><span class="keyword">while</span>(fa[next]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e[id[next]].v-=mn[T];</span><br><span class="line">e[id[next]^<span class="number">1</span>].v+=mn[T];</span><br><span class="line">next=fa[next];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(bfs())</span><br><span class="line">&#123;</span><br><span class="line">update();</span><br><span class="line">ansb+=dis[T]*mn[T];</span><br><span class="line">ansa+=mn[T];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read();m=read();S=read();T=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w,f;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">u=read();v=read();w=read();f=read();</span><br><span class="line">add(u,v,w,f);</span><br><span class="line">add(v,u,<span class="number">0</span>,-f);</span><br><span class="line">&#125;</span><br><span class="line">EK();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,ansa,ansb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说了最小费用，那么最大费用怎么办呢，还是一样，bfs时求最大费用，也可以转换为最小费用来做</p><p>转化为最小费用：建边的时候把正向边建成负的，反向边建成正的跑一遍最小费用就OK了</p><p>求最大费用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qu;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0xc0</span>,<span class="keyword">sizeof</span>(dis));<span class="comment">//建成极小值</span></span><br><span class="line"><span class="built_in">memset</span>(mn,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(mn));</span><br><span class="line"><span class="built_in">memset</span>(id,<span class="number">0</span>,<span class="keyword">sizeof</span>(id));</span><br><span class="line">dis[S]=<span class="number">0</span>;</span><br><span class="line">fa[S]=<span class="number">0</span>;</span><br><span class="line">qu.push(S);</span><br><span class="line"><span class="keyword">while</span>(!qu.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=qu.front();</span><br><span class="line">qu.pop();</span><br><span class="line">user[f1]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(e[i].v==<span class="number">0</span>||dis[t]&gt;=dis[f1]+e[i].w)<span class="keyword">continue</span>;<span class="comment">//&lt;=改为&gt;=</span></span><br><span class="line">dis[t]=dis[f1]+e[i].w;</span><br><span class="line">id[t]=i;</span><br><span class="line">fa[t]=f1;</span><br><span class="line">mn[t]=min(mn[f1],e[i].v);</span><br><span class="line"><span class="keyword">if</span>(user[t]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">qu.push(t);</span><br><span class="line">user[t]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[T]!=<span class="number">-0x3f3f3f40</span>;<span class="comment">//计算器算一下就知道了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题:<a href="https://www.luogu.org/problem/P4015" target="_blank" rel="noopener">运输问题</a>     <a href="https://www.luogu.org/problem/P4014" target="_blank" rel="noopener">分配问题</a>     <a href="https://www.luogu.org/problem/P2770" target="_blank" rel="noopener">航空路线问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;费用流是在最大流的基础上求出费用，满足费用最大或最小&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="费用流" scheme="http://www.scwyl.cn/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>最短路</title>
    <link href="http://www.scwyl.cn/2019/08/12/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>http://www.scwyl.cn/2019/08/12/最短路/</id>
    <published>2019-08-11T17:00:00.000Z</published>
    <updated>2019-08-11T15:46:34.728Z</updated>
    
    <content type="html"><![CDATA[<p>最短路问题（short-path problem）是<a href="https://baike.baidu.com/item/网络理论/7566965" target="_blank" rel="noopener">网络理论</a>解决的典型问题之一，可用来解决管路铺设、线路安装、厂区布局和设备更新等实际问题。基本内容是：若网络中的每条边都有一个数值（长度、成本、时间等），则找出两节点（通常是源节点和阱节点）之间总权和最小的路径就是最短路问题。</p><p>—-摘自百度百科</p><a id="more"></a><p>对于建图，有两种我推荐的</p><p>1.对于点少的可以用邻接矩阵来存，即dt(i)(j)=X;指的是i到j距离为X;</p><p>2.用链式前向星来存，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N],ei=<span class="number">0</span>;<span class="comment">//N为有几个点，ei为有几条边</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,next,v;&#125;;</span><br><span class="line">edge e[M*<span class="number">2</span>];<span class="comment">//无向图开2倍空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span><span class="comment">//从X指向Y的边权为V的边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ei++;<span class="comment">//边的数量+1</span></span><br><span class="line">    e[ei].to=y;<span class="comment">//这条边的终点</span></span><br><span class="line">    e[ei].v=v;<span class="comment">//这条边的边权为v</span></span><br><span class="line">    e[ei].next=h[x];</span><br><span class="line">    h[x]=ei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].next)<span class="comment">//遍历以x开始的边</span></span><br><span class="line">add(x,y,V);<span class="comment">//增加一条x-&gt;y价值为V的有向边</span></span><br></pre></td></tr></table></figure><p>而对于网络流中的ei初始值设为1，是为了快速找到反向的边，即ei^1为反向，ei为正向，建图时也是先建正向后建反向边。</p><h3 id="Floyed"><a href="#Floyed" class="headerlink" title="Floyed"></a>Floyed</h3><p>这种方式只适用于邻接矩阵，时间复杂度<script type="math/tex">o(n^3)</script></p><p>在n&lt;251是适用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)<span class="comment">//节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//起点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==k)<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//终点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j||j==k)<span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题:<a href="https://www.luogu.org/problem/P1119" target="_blank" rel="noopener">灾后重建</a></p><h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h3><p>都试用，时间复杂度最坏<script type="math/tex">O(ne)</script>，有些图会专门利用spfa的机制来卡，但spfa支持负边权，也能判断出负环</p><p>1.取出点。</p><p>2.更新dis</p><p>3.把没在堆栈中的点放进去</p><p>4.重复</p><p>5.最后的dis[i]就是起点到i点的距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> f)</span><span class="comment">//起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));<span class="comment">//从f到任意一条边的最短距离</span></span><br><span class="line">    dis[f]=<span class="number">0</span>;<span class="comment">//f到f的距离为0</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qu;</span><br><span class="line">    qu.push(f);</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> f1=qu.front();</span><br><span class="line">        qu.pop()</span><br><span class="line">            ++cnt[f1];<span class="comment">//当前这点被找了几次</span></span><br><span class="line">        <span class="keyword">if</span>(cnt[f1]&gt;n)<span class="keyword">return</span> <span class="number">0</span>;有负环</span><br><span class="line">            u[f1]=<span class="number">0</span><span class="comment">//f点在没在堆栈</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[f1];i;i=e[i].next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=e[i].to;</span><br><span class="line">                <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">                <span class="keyword">if</span>(dis[t]&gt;dis[f1]+v)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[t]=dis[f1]+v;</span><br><span class="line">                    <span class="keyword">if</span>(u[t]==<span class="number">0</span>)<span class="comment">//如果没在堆栈</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        qu.push(t);</span><br><span class="line">                        u[t]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u[f]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[f];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to=e[i].to,v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(dis[f]+v&lt;dis[to])<span class="comment">//能松散</span></span><br><span class="line">        &#123;</span><br><span class="line">            dis[to]=dis[f]+v;</span><br><span class="line">            <span class="keyword">if</span>(u[to]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">             <span class="keyword">if</span>(SPFA(v)==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    u[f]=<span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//没有负环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijskra"><a href="#dijskra" class="headerlink" title="dijskra"></a>dijskra</h3><p>时间复杂度<script type="math/tex">O(n^2)</script>,加了堆优化复杂度我不会算。。。,反正比<script type="math/tex">n^2</script>小不少</p><p>思路就是每次找出距离(已经找过的点)其他最近的点加入集合中</p><p>知道所有点全部找完</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijskra</span><span class="params">(<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[f]=<span class="number">0</span>;</span><br><span class="line">    pushheap(f,<span class="number">0</span>);<span class="comment">//入堆</span></span><br><span class="line">    <span class="keyword">while</span>(hpi)<span class="comment">//堆中有长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> f1=popheap();<span class="comment">//取出</span></span><br><span class="line">        <span class="keyword">if</span>(u[f1]==<span class="number">1</span>)<span class="keyword">continue</span>;<span class="comment">//已经使用过</span></span><br><span class="line">        u[f1]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[f1];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=e[i].to,v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[t]&gt;dis[f1]+v)<span class="comment">//能松散</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[t]=dis[f1]+v;<span class="comment">//松散</span></span><br><span class="line">                pushheap(t,dis[t]);<span class="comment">//进堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是堆优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp;x)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dis&gt;x.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node heap[n];</span><br><span class="line"><span class="keyword">int</span> hpi=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushheap</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> dis)</span><span class="comment">//把一个数据推进去</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hpi++;<span class="comment">//指针移一位</span></span><br><span class="line">    heap[hpi].id=id;</span><br><span class="line">    heap[hpi].dis=dis;</span><br><span class="line">    push_heap(heap+<span class="number">1</span>,heap+hpi+<span class="number">1</span>);<span class="comment">//推进堆</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popheap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pop_heap(heap+<span class="number">1</span>,heap+hpi+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=heap[hpi].id;</span><br><span class="line">    hpi--;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最短路问题（short-path problem）是&lt;a href=&quot;https://baike.baidu.com/item/网络理论/7566965&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网络理论&lt;/a&gt;解决的典型问题之一，可用来解决管路铺设、线路安装、厂区布局和设备更新等实际问题。基本内容是：若网络中的每条边都有一个数值（长度、成本、时间等），则找出两节点（通常是源节点和阱节点）之间总权和最小的路径就是最短路问题。&lt;/p&gt;
&lt;p&gt;—-摘自百度百科&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="最短路" scheme="http://www.scwyl.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>强连通分量</title>
    <link href="http://www.scwyl.cn/2019/08/11/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <id>http://www.scwyl.cn/2019/08/11/强连通分量/</id>
    <published>2019-08-11T13:30:00.000Z</published>
    <updated>2019-08-11T15:08:54.472Z</updated>
    
    <content type="html"><![CDATA[<p>强连通：如果两个顶点可以相互通达，则称两个顶点 强连通(strongly connected)。如果有向图G的每两个顶点都 强连通，称G是一个强连通图。非 强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。<br><a id="more"></a><br>简单来说就是图中有环，即<br><img src="/images/Tarjan1.jpg" alt><br>而tarjan使用来找环的<br><a href="https://www.luogu.org/problem/P3387" target="_blank" rel="noopener">缩点</a><br>思路:输入-&gt;tarjan-&gt;把环缩成一个点-&gt;spfa(dijskra)-&gt;输出-&gt;AC<br>首先输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,form;</span><br><span class="line">&#125;;</span><br><span class="line">edge e[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f1,<span class="keyword">int</span> f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ei++;</span><br><span class="line">e[ei].to=f2;</span><br><span class="line">e[ei].next=head[f1];</span><br><span class="line">e[ei].form=f1;</span><br><span class="line">head[f1]=ei;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ss=getchar();</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(ss&lt;<span class="string">'0'</span>||ss&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ss==<span class="string">'-'</span>)f=<span class="number">-1</span>;ss=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(ss&gt;=<span class="string">'0'</span>&amp;&amp;ss&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ss-<span class="string">'0'</span>;ss=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">n=read();m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i]=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=read(),f2=read();</span><br><span class="line">add(f1,f2);</span><br><span class="line">&#125;</span><br><span class="line">dotarjan();</span><br><span class="line">spfa();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[teamlist]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步就是tarjan找环缩点了</p><div class="table-container"><table><thead><tr><th>变量名</th><th>变量作用</th></tr></thead><tbody><tr><td>low[i]</td><td>i点的进入stack的时间</td></tr><tr><td>dfn[i]</td><td>从i点出发，所能访问到的最早的进入时间</td></tr><tr><td>teamindex</td><td>有几组</td></tr><tr><td>team[i]</td><td>i点是在第几组</td></tr><tr><td>indegree[i]</td><td>i点的入度</td></tr><tr><td>stindex</td><td>当前时间</td></tr><tr><td>vt[i]</td><td>当前第i组中所有点的权</td></tr></tbody></table></div><p>为了确保所有点都被找过，我们把每一个点都找一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dotarjan</span><span class="params">()</span><span class="comment">//调用tarjan</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=n;o++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dfn[o]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次掉用我们都让时间向前走一步,然后初始化low与dfn,并把当前点加入stack</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stindex++;</span><br><span class="line">low[f]=stindex;</span><br><span class="line">dfn[f]=stindex;</span><br><span class="line">st.push(f);</span><br></pre></td></tr></table></figure><p>然后我们试着往前继续找没找过的点直到找完，对于找过的点，如果那个点还没被分组，就更新low,此时的low可能会比dfn小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[f];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> to=e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(dfn[to]==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tarjan(to);</span><br><span class="line">        low[f]=min(low[f],low[to]);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(team[to]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            low[f]=min(dfn[to],low[f]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们怎么知道当前有没有找到一个环呢。这很简单，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dfn[f]==low[f])</span><br><span class="line">&#123;</span><br><span class="line">    这样就表示有环了，或者只有一个点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图:</p><p><img src="/images/Tarjan1.jpg" alt></p><p>试想一下，我从1开始dotarjan,他从1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</p><p>然后从8-&gt;3但是3已经被找过了，更新一路的low,发现从3开始环里面的low都与dfn[3]相等，</p><p>我们就可以增加一组，把环上所有点的点权和为一组的点权</p><p>但是这一个环上只有单个点怎么办，就如1，2，那就把1，2单独当成一组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dfn[f]==low[f])</span><br><span class="line">&#123;</span><br><span class="line">    teamindex++;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> top=st.top();</span><br><span class="line">        team[top]=teamindex;</span><br><span class="line">        st.pop();</span><br><span class="line">        vt[teamindex]+=v[top];</span><br><span class="line">        <span class="keyword">if</span>(top==f)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个tarjan函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stindex++;</span><br><span class="line">    low[f]=stindex;</span><br><span class="line">    dfn[f]=stindex;</span><br><span class="line">    st.push(f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[f];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(dfn[to]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(to);</span><br><span class="line">            low[f]=min(low[f],low[to]);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(team[to]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                low[f]=min(dfn[to],low[f]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[f]==low[f])</span><br><span class="line">    &#123;</span><br><span class="line">        teamindex++;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> top=st.top();</span><br><span class="line">            team[top]=teamindex;</span><br><span class="line">            st.pop();</span><br><span class="line">            vt[teamindex]+=v[top];</span><br><span class="line">            <span class="keyword">if</span>(top==f)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找完环了，这下该把环缩成点了，</p><p>怎么缩了，实际上已经处理好了只需要把ei数组更新一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doreduce</span><span class="params">()</span><span class="comment">//缩点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=ei;<span class="comment">//会用到之前的ei的值</span></span><br><span class="line">    ei=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="keyword">sizeof</span>(h));<span class="comment">//清楚所有记录</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(team[e[i].from]==team[e[i].to])<span class="keyword">continue</span>;<span class="comment">//这个点在环上就跳过</span></span><br><span class="line">        indegree[team[e[i].to]]++;</span><br><span class="line">        add(team[e[i].from],team[e[i].to]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩完点后就该spfa求最大权了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qu;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=teamlist;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ind[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">qu.push(i);</span><br><span class="line">ans[i]=vt[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!qu.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=qu.front();</span><br><span class="line">qu.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line">ind[to]--;</span><br><span class="line">ans[to]=max(ans[to],ans[f1]+vt[to]);</span><br><span class="line"><span class="keyword">if</span>(ind[to]==<span class="number">0</span>)qu.push(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+teamlist);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的ans[teamlist]就是答案</p><p>下边是我的AC的代码,我把缩点的那部分放到dotarjan里了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ei,n,m,ans[<span class="number">10005</span>],head[<span class="number">10005</span>],teamlist,vt[<span class="number">10005</span>],tmm,dfn[<span class="number">10005</span>],ind[<span class="number">10005</span>],v[<span class="number">10005</span>],team[<span class="number">10005</span>],low[<span class="number">10005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,form;</span><br><span class="line">&#125;;</span><br><span class="line">edge e[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f1,<span class="keyword">int</span> f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ei++;</span><br><span class="line">e[ei].to=f2;</span><br><span class="line">e[ei].next=head[f1];</span><br><span class="line">e[ei].form=f1;</span><br><span class="line">head[f1]=ei;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ss=getchar();</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(ss&lt;<span class="string">'0'</span>||ss&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ss==<span class="string">'-'</span>)f=<span class="number">-1</span>;ss=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(ss&gt;=<span class="string">'0'</span>&amp;&amp;ss&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ss-<span class="string">'0'</span>;ss=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> f1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tmm++;</span><br><span class="line">dfn[f1]=tmm;</span><br><span class="line">low[f1]=tmm;</span><br><span class="line">st.push(f1);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(dfn[to]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tarjan(to);</span><br><span class="line">low[f1]=min(low[to],low[f1]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(team[to]==<span class="number">0</span>)low[f1]=min(dfn[to],low[f1]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[f1]==low[f1])</span><br><span class="line">&#123;</span><br><span class="line">teamlist++;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">team[st.top()]=teamlist;</span><br><span class="line">vt[teamlist]+=v[st.top()];</span><br><span class="line"><span class="keyword">if</span>(st.top()==f1)</span><br><span class="line">&#123;</span><br><span class="line">st.pop();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dotarjan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(dfn[i]==<span class="number">0</span>)tarjan(i);</span><br><span class="line"><span class="keyword">int</span> l=ei;</span><br><span class="line">ei=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)head[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(team[e[i].form]==team[e[i].to])<span class="keyword">continue</span>;</span><br><span class="line">ind[team[e[i].to]]++;</span><br><span class="line">add(team[e[i].form],team[e[i].to]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qu;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=teamlist;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ind[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">qu.push(i);</span><br><span class="line">ans[i]=vt[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!qu.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=qu.front();</span><br><span class="line">qu.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line">ind[to]--;</span><br><span class="line">ans[to]=max(ans[to],ans[f1]+vt[to]);</span><br><span class="line"><span class="keyword">if</span>(ind[to]==<span class="number">0</span>)qu.push(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+teamlist);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">n=read();m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i]=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=read(),f2=read();</span><br><span class="line">add(f1,f2);</span><br><span class="line">&#125;</span><br><span class="line">dotarjan();</span><br><span class="line">spfa();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[teamlist]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题:</p><p><a href="https://www.luogu.org/problem/P1262" target="_blank" rel="noopener">间谍网络</a>     <a href="https://www.luogu.org/problem/P2341" target="_blank" rel="noopener">受欢迎的牛</a>     <a href="https://www.luogu.org/problem/P2746" target="_blank" rel="noopener">校园网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;强连通：如果两个顶点可以相互通达，则称两个顶点 强连通(strongly connected)。如果有向图G的每两个顶点都 强连通，称G是一个强连通图。非 强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Tarjan" scheme="http://www.scwyl.cn/tags/Tarjan/"/>
    
  </entry>
  
  <entry>
    <title>二分图匹配</title>
    <link href="http://www.scwyl.cn/2019/08/11/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    <id>http://www.scwyl.cn/2019/08/11/二分图匹配/</id>
    <published>2019-08-11T12:30:00.000Z</published>
    <updated>2019-08-11T12:46:53.596Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/二分图/9089095" target="_blank" rel="noopener">二分图</a>又称作二部图，是图论中的一种<a href="https://baike.baidu.com/item/特殊模型/19071206" target="_blank" rel="noopener">特殊模型</a>。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。</p><p>简而言之，就是顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。</p><p>—来自百度百科</p><p><a href="https://www.luogu.org/problem/P3386" target="_blank" rel="noopener">二分图匹配</a><br><a id="more"></a><br>二分图，如下图，左边之中的数据互不干扰，右边的数据互不干扰，左边之和右边有关</p><p><img src="/images/二分图1.jpg" alt></p><p>要求的是最大匹配数，看得出来，最大匹配数是5,分别是</p><p>1-&gt;2</p><p>3-&gt;4</p><p>5-&gt;6</p><p>7-&gt;8</p><p>9-&gt;10</p><p>那么怎么通过网络路来做题呢</p><p>如图，这样建图</p><p><img src="/images/二分图2.jpg" alt></p><p>左边红圈位源点，右边红圈为汇点。</p><p>但是二分匹配中左边一列和右边一列只允许只用一次，拆点</p><p><img src="/images/二分图3.jpg" alt></p><p>把，源点到其他点的流量设置为1，其他每个点到自身的流量设为1，这样就防止了每个点使用多次，</p><p>再把，黑色的边的流量设置为+∞(0x7f7f7f7f)，通过源点跑一遍最大流，最后的答案就是最大匹配了。</p><p>以下是代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> S,T,k,dep[<span class="number">100000</span>],f[<span class="number">100000</span>],mn[<span class="number">100000</span>],u[<span class="number">100000</span>],id[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> next,to,v;&#125;e[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> ei=<span class="number">1</span>,head[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ei++;</span><br><span class="line">e[ei].v=v;</span><br><span class="line">e[ei].next=head[x];</span><br><span class="line">e[ei].to=y;</span><br><span class="line">head[x]=ei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">register</span> <span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&lt;=<span class="string">'9'</span>&amp;&amp;s&gt;=<span class="string">'0'</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qu;</span><br><span class="line"><span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">qu.push(S);</span><br><span class="line">    dep[S]=<span class="number">1</span>;</span><br><span class="line">    qu.push(S);</span><br><span class="line"><span class="keyword">while</span>(!qu.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=qu.front();</span><br><span class="line">qu.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(e[i].v==<span class="number">0</span>||dep[to]!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">qu.push(to);</span><br><span class="line">dep[to]=dep[f1]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[T]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ansg[<span class="number">500</span>],g;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> maxflow,<span class="keyword">int</span> Fa,<span class="keyword">int</span> FA)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(from==T)<span class="keyword">return</span> maxflow;</span><br><span class="line"><span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[from];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(e[i].v==<span class="number">0</span>||dep[to]!=dep[from]+<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> res=dfs(to,min(maxflow-flow,e[i].v),from,Fa);</span><br><span class="line"><span class="keyword">if</span>(res==<span class="number">0</span>)dep[to]=<span class="number">0</span>;</span><br><span class="line">e[i].v-=res;</span><br><span class="line">e[i^<span class="number">1</span>].v+=res;</span><br><span class="line">flow+=res;</span><br><span class="line"><span class="keyword">if</span>(flow==maxflow)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bfs())ans+=dfs(S,<span class="number">0x3f3f3f3f</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read();m=read();k=read();</span><br><span class="line">S=n+m+<span class="number">1</span>;<span class="comment">//源点</span></span><br><span class="line">T=n+m+<span class="number">2</span>;<span class="comment">//汇点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=k;i++)<span class="comment">//自己到自己</span></span><br><span class="line">&#123;</span><br><span class="line">x=read();y=read()+n;</span><br><span class="line">add(x,y,<span class="number">0x7f7f7f7f</span>);</span><br><span class="line">add(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//到源点</span></span><br><span class="line">&#123;</span><br><span class="line">add(S,i,<span class="number">1</span>);</span><br><span class="line">add(i,S,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=m+n;i++)<span class="comment">//到汇点</span></span><br><span class="line">&#123;</span><br><span class="line">add(i,T,<span class="number">1</span>);</span><br><span class="line">add(T,i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">Dinic();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：</p><p><a href="https://www.luogu.org/problem/P3355" target="_blank" rel="noopener">骑士共存问题</a>     <a href="https://www.luogu.org/problem/P2774" target="_blank" rel="noopener">方格取数问题</a>     <a href="https://www.luogu.org/problem/P4014" target="_blank" rel="noopener">分配问题</a>     <a href="https://www.luogu.org/problem/P4015" target="_blank" rel="noopener">运输问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/二分图/9089095&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二分图&lt;/a&gt;又称作二部图，是图论中的一种&lt;a href=&quot;https://baike.baidu.com/item/特殊模型/19071206&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;特殊模型&lt;/a&gt;。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。&lt;/p&gt;
&lt;p&gt;简而言之，就是顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。&lt;/p&gt;
&lt;p&gt;—来自百度百科&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P3386&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二分图匹配&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="网络流" scheme="http://www.scwyl.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>网络最大流(EK)与(Dinic)</title>
    <link href="http://www.scwyl.cn/2019/08/06/%E7%BD%91%E7%BB%9C%E6%B5%81(EK)%E4%B8%8E(Dinic)/"/>
    <id>http://www.scwyl.cn/2019/08/06/网络流(EK)与(Dinic)/</id>
    <published>2019-08-06T05:00:00.000Z</published>
    <updated>2019-08-06T07:08:55.756Z</updated>
    
    <content type="html"><![CDATA[<p>这次讲的是最大流算法；</p><a id="more"></a><p>在一个有向图中，令a为源点,b为汇点，从a到b的最大流量为网络最大流,通俗的来讲，把a点当成一个管子的一端，b点当成另一个管子的一段，从a进去连着有许多大小不一的管子，最大流就是从a管无限多的水，问b点有多少水出来</p><p>模板题<a href="https://www.luogu.org/problem/P3376" target="_blank" rel="noopener">网络最大流</a></p><p>如图:</p><p><img src="/images/网络最大流1.jpg" alt></p><p>这时a-&gt;b的网络流为70,即A-&gt;7-&gt;8-&gt;B为10，A-&gt;1-&gt;2-&gt;B为10，A-&gt;4-&gt;6-&gt;5-&gt;B为30，A-&gt;4-&gt;3-&gt;5-&gt;B为20。</p><p>我们发现，通过一遍深搜就能得出答案，但如果是下面这幅图，深搜就可能为199，即a-&gt;1-&gt;2-&gt;b为1，a-&gt;1-&gt;b为99，a-&gt;2-&gt;b为99。</p><p><img src="/images/网络最大流2.jpg" alt></p><p>那么怎么跳过这种错误呢，我们把搜过的边全部反向建一条，把正边流过的流量弄到反向边里，即上图,a-&gt;1-&gt;2-&gt;b为1，那么，我把a-&gt;1减1，让1-&gt;a加1，让1-&gt;2减1,让2-&gt;1加1,让2-&gt;b减1,让b-&gt;2加1,这样就可以避免这种情况，但是，就像上边图一样，一但图中有很多这种情况，那就是T的飞起，所以我们在之前加上找最短路，让每一次更新的路径都是最短路，所以就有了EK算法。</p><h3 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h3><p>所谓EK算法，就是通过一边bfs,找到最短路，然后更新一遍最短路，如此往复。</p><p>下面是模板</p><div class="table-container"><table><thead><tr><th>变量名</th><th>变量作用</th></tr></thead><tbody><tr><td>dep[i]</td><td>第i个点在最短路中距离源点相隔(dep[i]-1)个点</td></tr><tr><td>f[i]</td><td>第i个点在最短路中的父节点是谁</td></tr><tr><td>mn[i]</td><td>第i个点得到的流量为多少</td></tr><tr><td>u[i]</td><td>第i个点在没在堆栈(queue)里</td></tr><tr><td>id[i]</td><td>第i个点在最短路中的正边是那一条，id[i]^1即在最短路中的负边是那一条</td></tr><tr><td>T</td><td>汇点，即终点</td></tr><tr><td>S</td><td>源点，即起点</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qu;</span><br><span class="line"><span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(mn,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(mn));</span><br><span class="line"><span class="built_in">memset</span>(u,<span class="number">0</span>,<span class="keyword">sizeof</span>(u));</span><br><span class="line"><span class="built_in">memset</span>(id,<span class="number">0</span>,<span class="keyword">sizeof</span>(id));</span><br><span class="line">dep[S]=<span class="number">1</span>;</span><br><span class="line">qu.push(S);</span><br><span class="line"><span class="keyword">while</span>(!qu.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=qu.front();</span><br><span class="line">qu.pop();</span><br><span class="line">u[f1]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(f1==T)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(e[i].v==<span class="number">0</span>||dep[t]!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">dep[t]=dep[f1]+<span class="number">1</span>;</span><br><span class="line">id[t]=i;</span><br><span class="line">f[t]=f1;</span><br><span class="line">mn[t]=min(mn[f1],e[i].v);</span><br><span class="line"><span class="keyword">if</span>(u[t]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">qu.push(t);</span><br><span class="line">u[t]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==T)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[T]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> next=T;</span><br><span class="line"><span class="keyword">while</span>(f[next]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e[id[next]].v-=mn[T];</span><br><span class="line">e[id[next]^<span class="number">1</span>].v+=mn[T];</span><br><span class="line">next=f[next];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mn[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(bfs())ans+=update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而存边是通过链式前向星存储,由于要存两条边，这里有个优化，即如果正边为1,反边就为1^1即2,所以ei为奇数就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> next,to,v;&#125;e[<span class="number">200003</span>];</span><br><span class="line"><span class="keyword">int</span> ei=<span class="number">1</span>,head[<span class="number">10003</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ei++;</span><br><span class="line">e[ei].v=v;</span><br><span class="line">e[ei].next=head[x];</span><br><span class="line">e[ei].to=y;</span><br><span class="line">head[x]=ei;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样又有一个问题，每次找到的最短路中dep[T]都是一样的，那该怎么优化，可以找到所有长度一样的最短路，全部都更新一遍，再找更长的，在更新，于是就有了Dinic算法</p><h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h3><p>所谓Dinic算法，就是在EK算法的基础上，通过一遍bfs找到最短路，然后根据最短路跑一遍dfs找到所有长度相等的最短路,然后更新</p><p>下面是模板</p><div class="table-container"><table><thead><tr><th>变量名</th><th>变量作用</th></tr></thead><tbody><tr><td>dep[i]</td><td>第i个点在最短路中距离源点相隔(dep[i]-1)个点</td></tr><tr><td>from</td><td>这点的编号</td></tr><tr><td>maxflow</td><td>流到这点的流量</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qu;</span><br><span class="line"><span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">qu.push(S);</span><br><span class="line">    dep[S]=<span class="number">1</span>;</span><br><span class="line">    qu.push(S);</span><br><span class="line"><span class="keyword">while</span>(!qu.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=qu.front();</span><br><span class="line">qu.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(e[i].v==<span class="number">0</span>||dep[to]!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">qu.push(to);</span><br><span class="line">dep[to]=dep[f1]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[T]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> maxflow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(from==T)<span class="keyword">return</span> maxflow;</span><br><span class="line"><span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[from];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(e[i].v==<span class="number">0</span>||dep[to]!=dep[from]+<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> res=dfs(to,min(maxflow-flow,e[i].v));</span><br><span class="line"><span class="keyword">if</span>(res==<span class="number">0</span>)dep[to]=<span class="number">0</span>;</span><br><span class="line">e[i].v-=res;</span><br><span class="line">e[i^<span class="number">1</span>].v+=res;</span><br><span class="line">flow+=res;</span><br><span class="line"><span class="keyword">if</span>(flow==maxflow)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bfs())</span><br><span class="line">    &#123;</span><br><span class="line"> ans+=dfs(S,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是通过链式前向星存储</p><p>在做题时，最重要的是要找源点和汇点，大多时候题目中都没有直接告诉，那么就需要自己去设，如图</p><p><img src="/images/网络最大流3.jpg" alt></p><p>例题：<a href="https://www.luogu.org/problem/P2756" target="_blank" rel="noopener">飞行员配对方案问题</a>     <a href="https://www.luogu.org/problem/P3386" target="_blank" rel="noopener">二分图匹配</a></p><p>而有些时候也需要拆点，即把同一个点拆乘几个，如图</p><p><img src="/images/网络最大流4.jpg" alt></p><p>例题：<a href="https://www.luogu.org/problem/P1231" target="_blank" rel="noopener">教辅的组成</a></p><p>还有比较综合的：<a href="https://www.luogu.org/problem/P2763" target="_blank" rel="noopener">试题库问题</a></p><p>有什么不懂可以下面问我</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次讲的是最大流算法；&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="网络流" scheme="http://www.scwyl.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>DP例题</title>
    <link href="http://www.scwyl.cn/2019/08/04/DP%E4%BE%8B%E9%A2%98/"/>
    <id>http://www.scwyl.cn/2019/08/04/DP例题/</id>
    <published>2019-08-04T15:30:00.000Z</published>
    <updated>2019-08-04T15:45:20.723Z</updated>
    
    <content type="html"><![CDATA[<p>本次例题是区间DP，<a href="https://www.luogu.org/problem/P1220" target="_blank" rel="noopener">关路灯</a></p><a id="more"></a><p>看完题目，我们知道这是个区间DP，在关第一个灯时，无非2种情况，C左边，C右边，当我们推广到第n个灯时，就会发现dp(1,n)=min(dp(1,n-1)+?,dp(2,n)+?),我们发现，没有办法究竟我在取的时候，我是在那一边的，因为这时在左或者在右会影响到答案，这是我们增加一维，<script type="math/tex">dp[i][j][k]</script>,i代表左边关了几盏，j表示右边关了几盏，k表示当前在左边还是右边，0为左，1为右</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sm(x,y) ((x&lt;=y)?(sum[y]-sum[x-1]):(0))<span class="comment">//[x,y]的功率和</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wwz(x,y) abs(a[y]-a[x])<span class="comment">//[x,y]的距离</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zd(x) abs(c-(x))<span class="comment">//左边第x个</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> yd(x) abs(c+(x))<span class="comment">//右边第x个</span></span></span><br></pre></td></tr></table></figure><p>由于本人太菜，中间改了无数遍，然后就定义了几个宏命令</p><p>以下是输入外加前缀和sum[i]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">register</span> <span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;=<span class="string">'9'</span>&amp;&amp;s&gt;=<span class="string">'0'</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">n=read();c=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i]=read();</span><br><span class="line">    b[i]=read();</span><br><span class="line">    <span class="keyword">if</span>(i==c)b[i]=<span class="number">0</span>;</span><br><span class="line">    sum[i]=sum[i<span class="number">-1</span>]+b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是算最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(dp));</span><br></pre></td></tr></table></figure><p>我们知道C点的灯关掉是一瞬间的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>然后我们分别算从C点往左和往右</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c;i++)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]+wwz(zd(i),zd(i<span class="number">-1</span>))*(sm(<span class="number">1</span>,zd(i))+sm(yd(<span class="number">1</span>),n));</span><br><span class="line">    dp[i][<span class="number">0</span>][<span class="number">1</span>]=dp[i][<span class="number">0</span>][<span class="number">0</span>]+wwz(zd(i),zd(<span class="number">0</span>))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(<span class="number">1</span>),n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-c;i++)</span><br><span class="line">&#123;</span><br><span class="line">    dp[<span class="number">0</span>][i][<span class="number">1</span>]=dp[<span class="number">0</span>][i<span class="number">-1</span>][<span class="number">1</span>]+wwz(yd(i<span class="number">-1</span>),yd(i))*(sm(<span class="number">1</span>,yd(<span class="number">0</span>))+sm(yd(i),n));</span><br><span class="line">    dp[<span class="number">0</span>][i][<span class="number">0</span>]=dp[<span class="number">0</span>][i][<span class="number">1</span>]+wwz(yd(<span class="number">0</span>),yd(i))*(sm(<span class="number">1</span>,zd(<span class="number">0</span>))+sm(yd(i+<span class="number">1</span>),n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后枚举左边和右边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c;i++)<span class="comment">//左边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-c;j++)<span class="comment">//右边</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i][j][<span class="number">0</span>]=min(dp[i][j][<span class="number">0</span>],min(dp[i<span class="number">-1</span>][j][<span class="number">0</span>]+wwz(zd(i),zd(i<span class="number">-1</span>))*(sm(<span class="number">1</span>,zd(i))+sm(yd(j+<span class="number">1</span>),n)),dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i))+sm(yd(j+<span class="number">1</span>),n))));</span><br><span class="line">dp[i][j][<span class="number">0</span>]=min(dp[i][j][<span class="number">0</span>],min((dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+wwz(yd(j<span class="number">-1</span>),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j),n))+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j+<span class="number">1</span>),n))),dp[i][j<span class="number">-1</span>][<span class="number">0</span>]+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j),n))+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j+<span class="number">1</span>),n))));</span><br><span class="line">dp[i][j][<span class="number">1</span>]=min(dp[i][j][<span class="number">1</span>],min(dp[i<span class="number">-1</span>][j][<span class="number">0</span>]+wwz(zd(i),zd(i<span class="number">-1</span>))*(sm(<span class="number">1</span>,zd(i))+sm(yd(j+<span class="number">1</span>),n))+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j+<span class="number">1</span>),n)),dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i))+sm(yd(j+<span class="number">1</span>),n))+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j+<span class="number">1</span>),n))));</span><br><span class="line">dp[i][j][<span class="number">1</span>]=min(dp[i][j][<span class="number">1</span>],min(dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+wwz(yd(j<span class="number">-1</span>),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j),n)),dp[i][j<span class="number">-1</span>][<span class="number">0</span>]+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j),n))));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合得到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,c,a[<span class="number">53</span>],b[<span class="number">53</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">53</span>],dp[<span class="number">53</span>][<span class="number">53</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">register</span> <span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;=<span class="string">'9'</span>&amp;&amp;s&gt;=<span class="string">'0'</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dp[左边关了多少][右边关了多少][当前在左边还是右边]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sm(x,y) ((x&lt;=y)?(sum[y]-sum[x-1]):(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wwz(x,y) abs(a[y]-a[x])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zd(x) abs(c-(x))<span class="comment">//在C左边第x个</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> yd(x) abs(c+(x))<span class="comment">//</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read();c=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=read();</span><br><span class="line">b[i]=read();</span><br><span class="line"><span class="keyword">if</span>(i==c)b[i]=<span class="number">0</span>;</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//左</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//右</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c;i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]+wwz(zd(i),zd(i<span class="number">-1</span>))*(sm(<span class="number">1</span>,zd(i))+sm(yd(<span class="number">1</span>),n));</span><br><span class="line"><span class="comment">//printf("dp[%d][%d][%d]=%d\n",i,0,0,dp[i][0][0]);</span></span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>]=dp[i][<span class="number">0</span>][<span class="number">0</span>]+wwz(zd(i),zd(<span class="number">0</span>))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(<span class="number">1</span>),n));</span><br><span class="line"><span class="comment">//printf("dp[%d][%d][%d]=%d\n",i,0,1,dp[i][0][1]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-c;i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[<span class="number">0</span>][i][<span class="number">1</span>]=dp[<span class="number">0</span>][i<span class="number">-1</span>][<span class="number">1</span>]+wwz(yd(i<span class="number">-1</span>),yd(i))*(sm(<span class="number">1</span>,yd(<span class="number">0</span>))+sm(yd(i),n));</span><br><span class="line"><span class="comment">//printf("dp[%d][%d][%d]=%d\n",0,i,1,dp[0][i][1]);</span></span><br><span class="line">dp[<span class="number">0</span>][i][<span class="number">0</span>]=dp[<span class="number">0</span>][i][<span class="number">1</span>]+wwz(yd(<span class="number">0</span>),yd(i))*(sm(<span class="number">1</span>,zd(<span class="number">0</span>))+sm(yd(i+<span class="number">1</span>),n));</span><br><span class="line"><span class="comment">//printf("dp[%d][%d][%d]=%d\n",0,i,0,dp[0][i][0]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c;i++)<span class="comment">//左边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-c;j++)<span class="comment">//右边</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i][j][<span class="number">0</span>]=min(dp[i][j][<span class="number">0</span>],min(dp[i<span class="number">-1</span>][j][<span class="number">0</span>]+wwz(zd(i),zd(i<span class="number">-1</span>))*(sm(<span class="number">1</span>,zd(i))+sm(yd(j+<span class="number">1</span>),n)),dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i))+sm(yd(j+<span class="number">1</span>),n))));</span><br><span class="line"><span class="comment">//printf("dp[%d][%d][%d]=%d\n",i,j,0,dp[i][j][0]);</span></span><br><span class="line">dp[i][j][<span class="number">0</span>]=min(dp[i][j][<span class="number">0</span>],min((dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+wwz(yd(j<span class="number">-1</span>),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j),n))+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j+<span class="number">1</span>),n))),dp[i][j<span class="number">-1</span>][<span class="number">0</span>]+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j),n))+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j+<span class="number">1</span>),n))));</span><br><span class="line"><span class="comment">//printf("dp[%d][%d][%d]=%d\n",i,j,0,dp[i][j][0]);</span></span><br><span class="line">dp[i][j][<span class="number">1</span>]=min(dp[i][j][<span class="number">1</span>],min(dp[i<span class="number">-1</span>][j][<span class="number">0</span>]+wwz(zd(i),zd(i<span class="number">-1</span>))*(sm(<span class="number">1</span>,zd(i))+sm(yd(j+<span class="number">1</span>),n))+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j+<span class="number">1</span>),n)),dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i))+sm(yd(j+<span class="number">1</span>),n))+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j+<span class="number">1</span>),n))));</span><br><span class="line"><span class="comment">//printf("dp[%d][%d][%d]=%d\n",i,j,1,dp[i][j][1]);</span></span><br><span class="line">dp[i][j][<span class="number">1</span>]=min(dp[i][j][<span class="number">1</span>],min(dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+wwz(yd(j<span class="number">-1</span>),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j),n)),dp[i][j<span class="number">-1</span>][<span class="number">0</span>]+wwz(zd(i),yd(j))*(sm(<span class="number">1</span>,zd(i+<span class="number">1</span>))+sm(yd(j),n))));</span><br><span class="line"><span class="comment">//printf("dp[%d][%d][%d]=%d\n",i,j,1,dp[i][j][1]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,min(dp[c<span class="number">-1</span>][n-c][<span class="number">1</span>],dp[c<span class="number">-1</span>][n-c][<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是本人的代码，由于本人DP方程瑕疵比较大，期间也有很多小毛病也改了无数遍。翻了翻题解，发现C点的位置是比较误导人的，这题是可以使用区间DP的模板，这里有些我认为写得很好的题解，各位可以去学习学习：<a href="https://www.luogu.org/blog/user44468/solution-p1220" target="_blank" rel="noopener">地址1</a>     <a href="https://www.luogu.org/blog/ButterflyDew/solution-p1220" target="_blank" rel="noopener">地址2</a>     <a href="https://www.luogu.org/blog/wobushixiaoming/solution-p1220" target="_blank" rel="noopener">地址3</a>     <a href="https://www.luogu.org/blog/user47136/solution-p1220" target="_blank" rel="noopener">dfs剪枝</a></p><p>有什么不懂可以下面问我</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次例题是区间DP，&lt;a href=&quot;https://www.luogu.org/problem/P1220&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关路灯&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="例题" scheme="http://www.scwyl.cn/categories/%E4%BE%8B%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://www.scwyl.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>莫队</title>
    <link href="http://www.scwyl.cn/2019/08/03/%E8%8E%AB%E9%98%9F/"/>
    <id>http://www.scwyl.cn/2019/08/03/莫队/</id>
    <published>2019-08-03T12:00:00.000Z</published>
    <updated>2019-08-04T15:14:48.001Z</updated>
    
    <content type="html"><![CDATA[<p>莫队算法，是为了维护一个区间的答案或最值。</p><a id="more"></a><p>本次例题：</p><p>难:<a href="https://www.luogu.org/problem/P1903" target="_blank" rel="noopener">数颜色 / 维护队列</a></p><p>易:<a href="https://www.luogu.org/problem/P2709" target="_blank" rel="noopener">小B的询问</a></p><h3 id="数颜色-维护队列"><a href="#数颜色-维护队列" class="headerlink" title="数颜色 / 维护队列"></a>数颜色 / 维护队列</h3><div class="table-container"><table><thead><tr><th>变量名</th><th>变量作用</th></tr></thead><tbody><tr><td>qnum</td><td>询问了几次</td></tr><tr><td>upnum</td><td>修改了几次</td></tr><tr><td>ans[i]</td><td>对于第i次询问的答案</td></tr><tr><td>now</td><td>现在更新了几次</td></tr><tr><td>cnt[i]</td><td>第i种颜色在区间内出现的次数</td></tr><tr><td>l</td><td>区间左端点</td></tr><tr><td>r</td><td>区间右端点</td></tr><tr><td>anser</td><td>当前区间答案</td></tr><tr><td>question[i]</td><td>第i次询问的参数</td></tr><tr><td>up[i]</td><td>第i次修改的参数</td></tr></tbody></table></div><p><img src="/images/莫队.jpg" alt></p><p>如图，我们，红色是我们要求的区间，黑色是我们当前的区间，我们需要让黑色指针移动到红色上然后更新答案，我们得一个一个移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//加入什么颜色</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(++cnt[x]==<span class="number">1</span>)ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//去掉什么颜色</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(--cnt[x]==<span class="number">0</span>)ans--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;question[i].l)del(a[l++]);</span><br><span class="line"><span class="keyword">while</span>(l&gt;question[i].l)add(a[--l]);</span><br><span class="line"><span class="keyword">while</span>(r&lt;question[i].r)add(a[++r]);</span><br><span class="line"><span class="keyword">while</span>(r&gt;question[i].r)del(a[r--]);</span><br></pre></td></tr></table></figure><p>可以看见，这样的话明显会T到飞</p><p>观察，每次取答案时我们，我们都会移动，但是会有只移动一点点的情况，也就是下一次区的区间与这次取的区间相差很小，</p><p>那么要通过什么办法可以让这种情况出现多次呢。</p><p>那就是sort，但要怎么写sort呢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> id,l,r,pl;&#125;question[<span class="number">50003</span>],up[<span class="number">50003</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.l/lo!=b.l/lo)<span class="keyword">return</span> a.l/lo&lt;b.l/lo;</span><br><span class="line">    <span class="keyword">if</span>(a.r/lo!=b.r/lo)<span class="keyword">return</span> a.r/lo&lt;b.r/lo;</span><br><span class="line">    <span class="keyword">return</span> a.pl&lt;b.pl;</span><br><span class="line">&#125;</span><br><span class="line">sort(question+<span class="number">1</span>,question+<span class="number">1</span>+qnum,cmp);</span><br></pre></td></tr></table></figure><p>这样我们就可以先通过l所在块排一次序，然后让l块一样的通过r所在块排一次序。</p><p>对于块的大小我们定义成<script type="math/tex">n^{2/3}</script>即lo=pow(n,2.0/3)</p><p>pl的含义是对于当前这次询问，需要从没有更新到更新pl次 </p><p>那么对于修改我们怎么修改呢。</p><p>对于当前区间内的我们可以这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> c)</span><span class="comment">//哪一次修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(up[c].l&gt;=l&amp;&amp;up[c].l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(++cnt[up[c].r]==<span class="number">1</span>)anser++;</span><br><span class="line"><span class="keyword">if</span>(--cnt[a[up[c].l]]==<span class="number">0</span>)anser--;</span><br><span class="line">&#125;</span><br><span class="line">swap(up[c].r,a[up[c].l]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于没有在当前区间的,我们swap两个的值</p><p>整理得</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> qnum,upnum,a[<span class="number">50003</span>],lo,n,m,ans[<span class="number">50003</span>];</span><br><span class="line"><span class="keyword">int</span> now,cnt[<span class="number">1000009</span>],anser,l=<span class="number">1</span>,r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> id,l,r,pl;&#125;question[<span class="number">50003</span>],up[<span class="number">50003</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.l/lo!=b.l/lo)<span class="keyword">return</span> a.l/lo&lt;b.l/lo;</span><br><span class="line">    <span class="keyword">if</span>(a.r/lo!=b.r/lo)<span class="keyword">return</span> a.r/lo&lt;b.r/lo;</span><br><span class="line">    <span class="keyword">return</span> a.pl&lt;b.pl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">register</span> <span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(up[c].l&gt;=l&amp;&amp;up[c].l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(++cnt[up[c].r]==<span class="number">1</span>)anser++;</span><br><span class="line"><span class="keyword">if</span>(--cnt[a[up[c].l]]==<span class="number">0</span>)anser--;</span><br><span class="line">&#125;</span><br><span class="line">swap(up[c].r,a[up[c].l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read();m=read();</span><br><span class="line">lo=<span class="built_in">pow</span>(n,<span class="number">2.0</span>/<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">char</span> f1[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,f1);</span><br><span class="line"><span class="keyword">if</span>(f1[<span class="number">0</span>]==<span class="string">'Q'</span>)</span><br><span class="line">&#123;</span><br><span class="line">question[++qnum].id=qnum;</span><br><span class="line">question[qnum].l=read();</span><br><span class="line">question[qnum].r=read();</span><br><span class="line">question[qnum].pl=upnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">up[++upnum].l=read();</span><br><span class="line">up[upnum].r=read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(question+<span class="number">1</span>,question+<span class="number">1</span>+qnum,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=qnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;question[i].l)<span class="keyword">if</span>(--cnt[a[l++]]==<span class="number">0</span>)anser--;</span><br><span class="line"><span class="keyword">while</span>(l&gt;question[i].l)<span class="keyword">if</span>(cnt[a[--l]]++==<span class="number">0</span>)anser++;</span><br><span class="line"><span class="keyword">while</span>(r&lt;question[i].r)<span class="keyword">if</span>(cnt[a[++r]]++==<span class="number">0</span>)anser++;</span><br><span class="line"><span class="keyword">while</span>(r&gt;question[i].r)<span class="keyword">if</span>(--cnt[a[r--]]==<span class="number">0</span>)anser--;</span><br><span class="line"><span class="keyword">while</span>(now&gt;question[i].pl)update(now--);</span><br><span class="line"><span class="keyword">while</span>(now&lt;question[i].pl)update(++now);</span><br><span class="line">ans[question[i].id]=anser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=qnum;i++)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小B的询问"><a href="#小B的询问" class="headerlink" title="小B的询问"></a>小B的询问</h3><p>这题相对于上题来说很简单，这时的lo就是<script type="math/tex">sqrt(n)</script></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,cnt[<span class="number">50003</span>],lo,k,n,m,a[<span class="number">50003</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anser,ans[<span class="number">50003</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> l,r,id,c;&#125;question[<span class="number">50003</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;<span class="built_in">putchar</span>(<span class="string">'0'</span>),<span class="built_in">putchar</span>(<span class="string">'\n'</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">32</span>],l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>) s[++l]=x%<span class="number">10</span>+<span class="number">48</span>,x/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&gt;=<span class="number">1</span>;i--) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a.c&lt;b.c||a.c==b.c&amp;&amp;a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read();m=read();k=read();</span><br><span class="line">lo=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">question[i].l=read();</span><br><span class="line">question[i].r=read();</span><br><span class="line">question[i].id=i;</span><br><span class="line">question[i].c=(question[i].l<span class="number">-1</span>)/lo+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(question+<span class="number">1</span>,question+<span class="number">1</span>+m,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;question[i].l)anser-=<span class="number">2</span>*(--cnt[a[l++]])+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&gt;question[i].l)anser+=<span class="number">2</span>*(++cnt[a[--l]])<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(r&lt;question[i].r)anser+=<span class="number">2</span>*(++cnt[a[++r]])<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(r&gt;question[i].r)anser-=<span class="number">2</span>*(--cnt[a[r--]])+<span class="number">1</span>;</span><br><span class="line">ans[question[i].id]=anser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)write(ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题的cmp我们是先根据所问问题的l所在块从小到大，然后在l所在块一样的情况下通过r从小到大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;莫队算法，是为了维护一个区间的答案或最值。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="暴力" scheme="http://www.scwyl.cn/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树(kruskal)与(prim)</title>
    <link href="http://www.scwyl.cn/2019/08/01/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://www.scwyl.cn/2019/08/01/最小生成树/</id>
    <published>2019-08-01T15:30:00.000Z</published>
    <updated>2019-08-03T09:35:49.676Z</updated>
    
    <content type="html"><![CDATA[<p>最小生成树，就是在无向图G中，有n个节点，找到n-1条边，是n个节点相连，且边权最小；</p><a id="more"></a><p>可以用kruskal与prim算法实现</p><p><a href="https://www.luogu.org/problem/P3366" target="_blank" rel="noopener">最小生成树模板</a></p><h3 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h3><p>废话不多说，直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ei,n,m,ans,cnt,f[<span class="number">5005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,from,to;&#125;;</span><br><span class="line">edge e[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ei++;</span><br><span class="line">e[ei].from=x;</span><br><span class="line">e[ei].to=y;</span><br><span class="line">e[ei].v=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findf</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x]==<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> findf(f[x]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f1=findf(x),f2=findf(y);</span><br><span class="line"><span class="keyword">if</span>(f1==f2)<span class="keyword">return</span>;</span><br><span class="line">f[f1]=f2;</span><br><span class="line">ans+=v;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge f1,edge f2)</span></span>&#123;<span class="keyword">return</span> f1.v&lt;f2.v;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sort(e+<span class="number">1</span>,e+<span class="number">1</span>+ei,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ei;i++)</span><br><span class="line">&#123;</span><br><span class="line">unio(e[i].from,e[i].to,e[i].v);</span><br><span class="line"><span class="keyword">if</span>(cnt==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read();m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=read(),f2=read(),f3=read();</span><br><span class="line">add(f1,f2,f3);</span><br><span class="line">&#125;</span><br><span class="line">Kruskal();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来Kruskal的简单</p><p>1.存边</p><p>2.把所有边以边权由小到大排序(sort)</p><p>3.从边权最小的开始取，只要边连接的两点不在同一个树上就通过并查集连起来，并把这条边的边权加入ans;</p><p>4.当cnt==n-1时就结束程序，因为最小生成树的边为节点数-1。</p><h3 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h3><p>相比于Kruskal,prim比较麻烦。</p><p>prim,是以任意节点开始，找出与这点连接的所有边，最后取最小的，找到新节点后继续，需要维护一个数组，记录其他没找过的点到找过的点的最短距离</p><div class="table-container"><table><thead><tr><th>变量名</th><th>变量作用</th></tr></thead><tbody><tr><td>cnt</td><td>已经找到的边数量</td></tr><tr><td>dis[i]</td><td>i点到找过的点的最短距离</td></tr><tr><td>ans</td><td>最小生成树的边权和</td></tr><tr><td>user[i]</td><td>i点找没找过</td></tr></tbody></table></div><p>先存边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,v,next;&#125;e[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>),s=getchar();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++ei].v=v;</span><br><span class="line">    e[ei].to=y;</span><br><span class="line">    e[ei].next=head[x];</span><br><span class="line">    head[x]=ei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read();m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,f1,f2,f3;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f1=read(),f2=read(),f3=read();</span><br><span class="line">        add(f1,f2,f3),</span><br><span class="line">add(f2,f1,f3);</span><br><span class="line">    &#125;</span><br><span class="line">    prim();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据prim写法，维护dis数组，把根定为1，先设为极大值，在根据节点1更新dis数值，只更新与1相连的节点的dis值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[<span class="number">1</span>];i;i=e[i].next)dis[e[i].to]=min(dis[e[i].to],e[i].v);</span><br></pre></td></tr></table></figure><p>更新完，我们找dis非0且最小的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> minn=<span class="number">0x7f7f7f7f</span>;</span><br><span class="line">user[now]=<span class="number">1</span>;</span><br><span class="line">dis[now]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!user[i]&amp;&amp;minn&gt;dis[i])</span><br><span class="line">    &#123;</span><br><span class="line">        minn=dis[i];</span><br><span class="line">        now=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>now即为我们下次的根了</p><p>根据now更新dis,并把之前的now与这个now直接的边权加上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ans+=minn;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> to=e[i].to;</span><br><span class="line">    dis[to]=min(e[i].v,dis[to]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后不可能一直这样下去，有一个边界</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cnt&lt;n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面才是prim函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[<span class="number">1</span>];i;i=e[i].next)dis[e[i].to]=min(dis[e[i].to],e[i].v);</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minn=<span class="number">0x7f7f7f7f</span>;</span><br><span class="line">        user[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!user[i]&amp;&amp;minn&gt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                minn=dis[i];</span><br><span class="line">                now=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=minn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to=e[i].to;</span><br><span class="line">            dis[to]=min(e[i].v,dis[to]);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有堆优化，可以更快，这里就不写的</p><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>从之前的代码中可以看出，kruskal的复杂度是根据边的多少来的，而prim是根据点来的，Prim在稠密图中比Kruskal优，在稀疏图中比Kruskal劣。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>还有一种叫Borůvka (Sollin)求最小生成树的，在维基百科上有<a href="https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm" target="_blank" rel="noopener">地址</a>,不过需要翻墙才能看。</p><p>有什么不懂可以在下面问我</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最小生成树，就是在无向图G中，有n个节点，找到n-1条边，是n个节点相连，且边权最小；&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="http://www.scwyl.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LCA</title>
    <link href="http://www.scwyl.cn/2019/07/30/LCA/"/>
    <id>http://www.scwyl.cn/2019/07/30/LCA/</id>
    <published>2019-07-30T15:30:00.000Z</published>
    <updated>2019-08-03T09:36:48.168Z</updated>
    
    <content type="html"><![CDATA[<p>LCA(最近公共祖先)，指在有根树中，找出某两个结点u和v最近的公共祖先</p><a id="more"></a><p>例题：<a href="https://www.luogu.org/problem/P3379" target="_blank" rel="noopener">【模板】最近公共祖先（LCA）</a></p><p>求LCA我知道2种方法，一种是在线的，一种是离线；</p><p>在线的是用倍增求的，离线的是用tanjar的算法求的</p><p>离线的求完后就不能在更改了；</p><p>而在线的求完，可以在最后加点之类的；</p><h3 id="离线-tanjar"><a href="#离线-tanjar" class="headerlink" title="离线(tanjar)"></a>离线(tanjar)</h3><p>先上图：</p><p><img src="/images/LCA.jpg" alt></p><p>这张图中</p><p>lca(5,16)=2</p><p>lca(2,6)=2</p><p>lca(11,16)=9</p><p>这不难发现规律，很快我们便总结出一个暴力办法:</p><p>以lca(5,16)为例,让他们先爬到深度一样的位置上，即5-&gt;5,16-&gt;7;</p><p>然后让两边一起往上爬，知道相遇,</p><p>5-&gt;5-&gt;3-&gt;2</p><p>16-&gt;7-&gt;4-&gt;2</p><p>当然，这暴力会T飞掉，开了o2都没用。</p><p>下面我介绍tanjar做法</p><p>这种做法会用到并查集</p><div class="table-container"><table><thead><tr><th>变量名</th><th style="text-align:center">变量作用</th></tr></thead><tbody><tr><td>used[i]</td><td style="text-align:center">i节点找没找过</td></tr><tr><td>ans[i]</td><td style="text-align:center">第i次询问的答案</td></tr></tbody></table></div><p>1.先建立两个链表，一个为树的各条边(根据题目建双向)，另一个是查询的两节点(建双向)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[Maxn];</span><br><span class="line"><span class="keyword">int</span> head[Maxn],ei=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ei++;</span><br><span class="line">    e[ei].to=y;</span><br><span class="line">    e[ei].next=head[x];</span><br><span class="line">    head[x]=ei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-=-=-=-=-=-=--=-=--=-=-=-=-=-=--=-=--=-=</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next,id;<span class="comment">//id：这次询问在总询问的第几个</span></span><br><span class="line">&#125;e2[Maxn];</span><br><span class="line"><span class="keyword">int</span> head2[Maxn],ei2=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ei2++;</span><br><span class="line">    e2[ei2].id=id;</span><br><span class="line">    e2[ei2].to=y;</span><br><span class="line">    e2[ei2].next=head2[x];</span><br><span class="line">    head2[x]=ei2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.根开始进行一遍深搜(可能没有根，这是可以随意选一个点为根)。</p><p>3.先把该节点i的f设置为自身，然后搜索与此节点相连的所有点j，如果点j没被搜索过，则进入点j的搜索，搜索完后把点j的f指向i。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">used[f]=<span class="number">1</span>;<span class="comment">//搜索的打上标记</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f];i;i=e[i].next)</span><br><span class="line">&#123;<span class="comment">//找节点</span></span><br><span class="line">    <span class="keyword">int</span> to=e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(used[to]==<span class="number">1</span>)<span class="comment">//找过的节点不在找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lca(to);</span><br><span class="line">    uion(f,to);<span class="comment">//这里把to节点弄完后才把to的findf指向f是为了找最近的，而不是找到to上面的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.深搜完一点i后，开始判断节点i与另一节点j是否满足求LCA的条件，如何判断呢，只需要看j是否被搜索过，如果被搜索过，那么把ans[id]=findf(to)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head2[f];i;i=e2[i].next)</span><br><span class="line">&#123;<span class="comment">//找关系</span></span><br><span class="line">    <span class="keyword">int</span> to=e2[i].to;</span><br><span class="line">    <span class="keyword">if</span>(used[to]==<span class="number">1</span>)<span class="comment">//只要这个点和关系点都被找过，那么他们的lca就是findf(to),这时的findf(to)还没有指向更高一级</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[e2[i].id]=findf(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.搜索完所有点，自动退出初始的第一个深搜，输出结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是总的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n+m)。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn 5000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxm 5000100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,root;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[Maxn];</span><br><span class="line"><span class="keyword">int</span> head[Maxn],ei=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ei++;</span><br><span class="line">    e[ei].to=y;</span><br><span class="line">    e[ei].next=head[x];</span><br><span class="line">    head[x]=ei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next,id;<span class="comment">//id：这次询问在总询问的第几个</span></span><br><span class="line">&#125;e2[Maxn];</span><br><span class="line"><span class="keyword">int</span> head2[Maxn],ei2=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ei2++;</span><br><span class="line">    e2[ei2].id=id;</span><br><span class="line">    e2[ei2].to=y;</span><br><span class="line">    e2[ei2].next=head2[x];</span><br><span class="line">    head2[x]=ei2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------并查集</span></span><br><span class="line"><span class="keyword">int</span> f[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findf</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x]==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x]=findf(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uion</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=findf(x);</span><br><span class="line">    y=findf(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)</span><br><span class="line">    &#123;</span><br><span class="line">        f[y]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------</span></span><br><span class="line"><span class="keyword">int</span> used[Maxn];</span><br><span class="line"><span class="keyword">int</span> ans[Maxm];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    used[f]=<span class="number">1</span>;<span class="comment">//搜索的打上标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[f];i;i=e[i].next)</span><br><span class="line">    &#123;<span class="comment">//找节点</span></span><br><span class="line">        <span class="keyword">int</span> to=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(used[to]==<span class="number">1</span>)<span class="comment">//找过的节点不在找</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lca(to);</span><br><span class="line">        uion(f,to);<span class="comment">//这里把to节点弄完后才把to的findf指向f是为了找最近的，而不是找到to上面的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head2[f];i;i=e2[i].next)</span><br><span class="line">    &#123;<span class="comment">//找关系</span></span><br><span class="line">        <span class="keyword">int</span> to=e2[i].to;</span><br><span class="line">        <span class="keyword">if</span>(used[to]==<span class="number">1</span>)<span class="comment">//只要这个点和关系点都被找过，那么他们的lca就是findf(to),这时的findf(to)还没有指向更高一级</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans[e2[i].id]=findf(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        add(x,y);<span class="comment">//建边</span></span><br><span class="line">        add(y,x);<span class="comment">//无向图</span></span><br><span class="line">    &#125;<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);<span class="comment">//需要搜索的lca(a,b);</span></span><br><span class="line">        add2(a,b,i);<span class="comment">//建立关系</span></span><br><span class="line">        add2(b,a,i);<span class="comment">//建立关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    lca(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);<span class="comment">//输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在线-倍增"><a href="#在线-倍增" class="headerlink" title="在线(倍增)"></a>在线(倍增)</h3><p>先上图：</p><p><img src="/images/LCA.jpg" alt></p><p>围绕倍增的思想，原来的暴力算法是一步一步往上爬，这次我们四步二步一步的爬</p><p>也就是虫子向上爬<script type="math/tex">2^i</script>次=虫子向上<script type="math/tex">2^{i-1}</script>再向上<script type="math/tex">2^{i-1}</script>，即<script type="math/tex">2^i=2^{i-1}+2^{i-1}</script>;</p><p>先打个log2的表,比直接取log2快</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qulog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>变量名</th><th style="text-align:center">变量作用</th></tr></thead><tbody><tr><td>lg[i]</td><td style="text-align:center"><script type="math/tex">log~2~^i</script>的值</td></tr><tr><td>dep[i]</td><td style="text-align:center">第i节点的深度，根深度为1</td></tr><tr><td>f(i)(j)</td><td style="text-align:center">第i个点向上<script type="math/tex">2^j</script>的节点</td></tr></tbody></table></div><p>然后我们从根节点开始，求每一个点的dep与f(i)(0)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[g];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(dep[to]!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">dep[to]=dep[g]+<span class="number">1</span>;</span><br><span class="line">f[to][<span class="number">0</span>]=g;</span><br><span class="line">dfs(to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们开始补全f数组，怎么补全呢？</p><p>利用<script type="math/tex">2^i=2^{i-1}+2^{i-1}</script>;进行补全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qu2x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;i++)<span class="comment">//根据有多少点来判断i&lt;=什么</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(f[j][i<span class="number">-1</span>]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">f[j][i]=f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];<span class="comment">//j向上2^i次=j向上2^(i-1)再向上2^(i-1)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备工作做完了，开始lca函数了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> f1,<span class="keyword">int</span> f2)</span><span class="comment">//求lca的节点编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[f1]&gt;dep[f2])swap(f1,f2);<span class="comment">//让f2在f1下面</span></span><br><span class="line">f2=tiao(f2,dep[f2]-dep[f1]);<span class="comment">//先让f2的深度==f1</span></span><br><span class="line"><span class="keyword">if</span>(f2==f1)<span class="keyword">return</span> f1;<span class="comment">//特判</span></span><br><span class="line">    <span class="comment">//---------------------------------二分</span></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=dep[f1]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(tiao(f1,mid)==tiao(f2,mid))<span class="comment">//只要跳到同一点了，那么就不动</span></span><br><span class="line">&#123;</span><br><span class="line">r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tiao(f1,r);</span><br><span class="line">    <span class="comment">//---------------------------------二分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面二分处也可以改为这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[dep[f1]]<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[f1][i]!=fa[f2][i])</span><br><span class="line">    &#123;</span><br><span class="line">    f1=f[f1][i];</span><br><span class="line">        f2=f[f2][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[f1][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>那么tiao函数怎么写呢，观察，假如，一个点向上跳5步，可以先跳<script type="math/tex">2^2</script>再跳<script type="math/tex">2^0</script>步,且<script type="math/tex">2^t</script>=(1&lt;&lt;t)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tiao</span><span class="params">(<span class="keyword">int</span> g,<span class="keyword">int</span> jibu)</span><span class="comment">//g点向上跳jibu步</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(jibu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=lg[jibu];</span><br><span class="line">g=f[g][t];<span class="comment">//g向上跳2^t步</span></span><br><span class="line">jibu=jibu-(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理得到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> next,to;&#125;;</span><br><span class="line">edge e[<span class="number">1000003</span>];</span><br><span class="line"><span class="keyword">int</span> ei,head[<span class="number">500003</span>],N,M,S,lg[<span class="number">500003</span>],dep[<span class="number">500003</span>],f[<span class="number">500003</span>][<span class="number">33</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f1,<span class="keyword">int</span> f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ei++;</span><br><span class="line">e[ei].to=f2;</span><br><span class="line">e[ei].next=head[f1];</span><br><span class="line">head[f1]=ei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qulog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[g];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(dep[to]!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">dep[to]=dep[g]+<span class="number">1</span>;</span><br><span class="line">f[to][<span class="number">0</span>]=g;</span><br><span class="line">dfs(to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qu2x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(f[j][i<span class="number">-1</span>]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">f[j][i]=f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];<span class="comment">//j向上2^i次=j向上2^(i-1)再向上2^(i-1)</span></span><br><span class="line"><span class="comment">//2^i=2^(i-1)+2^(i-1)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tiao</span><span class="params">(<span class="keyword">int</span> g,<span class="keyword">int</span> jibu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(jibu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=lg[jibu];</span><br><span class="line">g=f[g][t];<span class="comment">//g向上跳2^t步</span></span><br><span class="line">jibu=jibu-(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> f1,<span class="keyword">int</span> f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[f1]&gt;dep[f2])swap(f1,f2);</span><br><span class="line">f2=tiao(f2,dep[f2]-dep[f1]);</span><br><span class="line"><span class="keyword">if</span>(f2==f1)<span class="keyword">return</span> f1;</span><br><span class="line">    <span class="comment">//--------------------第一种----------------------</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lg[dep[f1]]<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[f1][i]!=fa[f2][i])</span><br><span class="line">    &#123;</span><br><span class="line">    f1=f[f1][i];</span><br><span class="line">        f2=f[f2][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[f1][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//--------------------第一种----------------------</span></span><br><span class="line">    <span class="comment">//--------------------第2种----------------------</span></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=dep[f1]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(tiao(f1,mid)==tiao(f2,mid))</span><br><span class="line">&#123;</span><br><span class="line">r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tiao(f1,r);</span><br><span class="line">    <span class="comment">//--------------------第2种----------------------</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;N,&amp;M,&amp;S);</span><br><span class="line">dep[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,f1,f2;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">        scnaf(<span class="string">"%d%d"</span>,&amp;f1,&amp;f2);</span><br><span class="line">add(f1,f2);<span class="comment">//无向图，建两次</span></span><br><span class="line">add(f2,f1);</span><br><span class="line">&#125;</span><br><span class="line">qulog();</span><br><span class="line">dfs(S);</span><br><span class="line">qu2x();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=read(),f2=read();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lca(f1,f2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有什么不懂可以在下面问我</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LCA(最近公共祖先)，指在有根树中，找出某两个结点u和v最近的公共祖先&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="http://www.scwyl.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>离散化</title>
    <link href="http://www.scwyl.cn/2019/07/28/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>http://www.scwyl.cn/2019/07/28/离散化/</id>
    <published>2019-07-28T12:00:00.000Z</published>
    <updated>2019-08-03T09:33:22.958Z</updated>
    
    <content type="html"><![CDATA[<p>离散化，即不在改变数据相对大小的条件下，对数据进行相应的缩小</p><a id="more"></a><p>例如：</p><p>这里有6个数</p><p>5613,15611,616,1 64,6164,6164离散化后就成了3,5,2,1,4,4</p><p>方法很简单</p><p>1.排序//用sort</p><p>2.删除重复元素//用unique</p><p>3.求元素离散化后对应的值//用lower_bound或者upper_bound</p><p>//lower_bound会从0开始，upper_bound则从1开始</p><p>a为原始序列，b为离散后的序列</p><p>代码也很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">int</span> size=unique(a+<span class="number">1</span>,a+<span class="number">1</span>+n)-a<span class="number">-1</span>;<span class="comment">//size为离散化后元素个数</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">b[i]=upper_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+size,a[i])-a;<span class="comment">//a[i]经离散化后对应的值</span></span><br></pre></td></tr></table></figure><p>有不懂的可以下面问我</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;离散化，即不在改变数据相对大小的条件下，对数据进行相应的缩小&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="离散化" scheme="http://www.scwyl.cn/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>分块</title>
    <link href="http://www.scwyl.cn/2019/07/28/%E5%88%86%E5%9D%97/"/>
    <id>http://www.scwyl.cn/2019/07/28/分块/</id>
    <published>2019-07-28T09:00:00.000Z</published>
    <updated>2019-08-03T09:37:37.737Z</updated>
    
    <content type="html"><![CDATA[<p>分块，就是把大的方块划分成一个一个的小方块，简而言之就是线段树的弱化版。</p><a id="more"></a><p><a href="https://www.luogu.org/problem/P3372" target="_blank" rel="noopener">[模板]线段树 1</a></p><div class="table-container"><table><thead><tr><th>变量名</th><th>变量作用</th></tr></thead><tbody><tr><td>block_max</td><td>每一块最多有多少</td></tr><tr><td>block_num[i]</td><td>第i个数据是哪一块的</td></tr><tr><td>sum[i]</td><td>第i个块的数据和</td></tr><tr><td>a[i]</td><td>初始数据</td></tr><tr><td>pl[i]</td><td>第i个块所有数据的增添量</td></tr></tbody></table></div><p>我们一半把block_max设置为总数的根号，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block_max=<span class="built_in">sqrt</span>(n);</span><br></pre></td></tr></table></figure><p>但有些题目如果更改一下block_max的大小会有出奇的效果</p><p>那怎么判断第i个数属于那一块呢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block_num[i]=(i<span class="number">-1</span>)/block_max+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为我让第一块编号为1，所以+1；</p><p>在输入时就对sum[i]初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum[block_num[i]]+=a[i];</span><br></pre></td></tr></table></figure><p>输入弄完了，那怎么对其区间[l,r]进行增添数据呢</p><h6 id="增添数据"><a href="#增添数据" class="headerlink" title="增添数据"></a>增添数据</h6><p>无非就2种情况</p><p>1.block_num[l]==block_num[r];</p><p>这种情况可以这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i]+=p;</span><br><span class="line">&#125;</span><br><span class="line">sum[block_num[l]]+=(r-l+<span class="number">1</span>)*p;</span><br></pre></td></tr></table></figure><p>2.block_num[l]!=block_num[r];</p><p>对于l所在块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=block_max*block_num[l];i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i]+=p;</span><br><span class="line">&#125;</span><br><span class="line">sum[block_num[l]]+=(block_max*block_num[l]-l+<span class="number">1</span>)*p;</span><br></pre></td></tr></table></figure><p>对于r所在块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=(block_num[r]<span class="number">-1</span>)*block_max+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i]+=p;</span><br><span class="line">    sum[block_num[i]]+=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里(block_num[r]-1)*block_max+1是为了求r所在块的第一个数据的编号</p><p>对于l,r之间的块可以这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=block_num[l]+<span class="number">1</span>;i&lt;=block_num[r]<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum[i]+=block_max*p;</span><br><span class="line">    pl[i]+=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=min(r,block_num[l]*block_max);i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]+=p;</span><br><span class="line">&#125;</span><br><span class="line">    sum[block_num[l]]+=(min(r,block_num[l]*block_max)-l+<span class="number">1</span>)*p;</span><br><span class="line"><span class="keyword">if</span>(block_num[l]!=block_num[r])<span class="comment">//l,r不在同一块</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=(block_num[r]<span class="number">-1</span>)*block_max+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]+=p;</span><br><span class="line">&#125;</span><br><span class="line">        sum[block_num[r]]+=(r-(block_num[r]<span class="number">-1</span>)*block_max)*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=block_num[l]+<span class="number">1</span>;i&lt;=block_num[r]<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum[i]+=block_max*p;</span><br><span class="line">pl[i]+=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h6><p>和修改数据一样</p><p>对于l所在块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=min(r,block_num[l]*block_max);i++)</span><br><span class="line">&#123;</span><br><span class="line">    ans+=a[i];</span><br><span class="line">&#125;</span><br><span class="line">ans+=pl[block_num[l]]*(min(r,block_num[l]*block_max)-l+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>对于r所在块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=(block_num[r]<span class="number">-1</span>)*block_max+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ans+=a[i];</span><br><span class="line">]</span><br><span class="line">ans+=pl[block_num[r]]*(r-(block_num[r]<span class="number">-1</span>)*block_max);</span><br></pre></td></tr></table></figure><p>对于l,r中间块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=block_num[l]+<span class="number">1</span>;i&lt;=block_num[r]<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=sum[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是整合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=min(r,block_num[l]*block_max);i++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=a[i];</span><br><span class="line">&#125;</span><br><span class="line">ans+=pl[block_num[l]]*(min(r,block_num[l]*block_max)-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(block_num[l]!=block_num[r])<span class="comment">//不在同一块</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=(block_num[r]<span class="number">-1</span>)*block_max+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ans+=a[i];</span><br><span class="line">&#125;</span><br><span class="line">ans+=pl[block_num[r]]*(r-(block_num[r]<span class="number">-1</span>)*block_max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=block_num[l]+<span class="number">1</span>;i&lt;=block_num[r]<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是这次的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,block_max,a[<span class="number">100055</span>],block_num[<span class="number">100055</span>],pl[<span class="number">500</span>],sum[<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> l,<span class="keyword">long</span> <span class="keyword">long</span> r,<span class="keyword">long</span> <span class="keyword">long</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=l;i&lt;=min(r,block_num[l]*block_max);i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]+=p;</span><br><span class="line">&#125;</span><br><span class="line">    sum[block_num[l]]+=(min(r,block_num[l]*block_max)-l+<span class="number">1</span>)*p;</span><br><span class="line"><span class="keyword">if</span>(block_num[l]!=block_num[r])<span class="comment">//l,r不在同一块</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=(block_num[r]<span class="number">-1</span>)*block_max+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]+=p;</span><br><span class="line">&#125;</span><br><span class="line">        sum[block_num[r]]+=(r-(block_num[r]<span class="number">-1</span>)*block_max)*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=block_num[l]+<span class="number">1</span>;i&lt;=block_num[r]<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum[i]+=block_max*p;</span><br><span class="line">pl[i]+=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> l,<span class="keyword">long</span> <span class="keyword">long</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=l;i&lt;=min(r,block_num[l]*block_max);i++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=a[i];</span><br><span class="line">&#125;</span><br><span class="line">ans+=pl[block_num[l]]*(min(r,block_num[l]*block_max)-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(block_num[l]!=block_num[r])<span class="comment">//不在同一块</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=(block_num[r]<span class="number">-1</span>)*block_max+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ans+=a[i];</span><br><span class="line">&#125;</span><br><span class="line">ans+=pl[block_num[r]]*(r-(block_num[r]<span class="number">-1</span>)*block_max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=block_num[l]+<span class="number">1</span>;i&lt;=block_num[r]<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read();m=read();</span><br><span class="line">block_max=<span class="built_in">sqrt</span>(n);<span class="comment">//每一个块大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=read();</span><br><span class="line">block_num[i]=(i<span class="number">-1</span>)/block_max+<span class="number">1</span>;<span class="comment">//第i个数属于哪一块</span></span><br><span class="line">sum[block_num[i]]+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f1=read();</span><br><span class="line"><span class="keyword">if</span>(f1==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f2=read(),f3=read(),f4=read();</span><br><span class="line">add(f2,f3,f4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f2=read(),f3=read();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(f2,f3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>码风巨丑，见谅</p><p>有不懂的可以下面问我</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分块，就是把大的方块划分成一个一个的小方块，简而言之就是线段树的弱化版。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="暴力" scheme="http://www.scwyl.cn/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>树链剖分</title>
    <link href="http://www.scwyl.cn/2019/07/27/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    <id>http://www.scwyl.cn/2019/07/27/树链剖分/</id>
    <published>2019-07-27T15:30:00.000Z</published>
    <updated>2019-08-03T09:37:11.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将一棵树划分成若干条链，用数据结构去维护每条链，复杂度为O(logN)<br><a id="more"></a></p><h3 id="树链剖分模板题"><a href="#树链剖分模板题" class="headerlink" title="树链剖分模板题"></a><a href="https://www.luogu.org/problem/P3384" target="_blank" rel="noopener">树链剖分模板题</a></h3><p><img src="/images/树链剖分1.jpg" alt></p><p>变量：</p><div class="table-container"><table><thead><tr><th>变量名</th><th style="text-align:center">变量作用</th></tr></thead><tbody><tr><td>dep[i]</td><td style="text-align:center">第i个点的深度[根节点深度为0]</td></tr><tr><td>fa[i]</td><td style="text-align:center">第i个点的父节点[根节点的父节点为本身]</td></tr><tr><td>siz[i]</td><td style="text-align:center">第i个点下面有多少个点(包括自己)</td></tr><tr><td>hson[i]</td><td style="text-align:center">第i个点它的子节点中siz最大的点</td></tr></tbody></table></div><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> f)</span><span class="comment">//当前点，父节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[r]=dep[f]+<span class="number">1</span>;<span class="comment">//当前点深度=父节点+1</span></span><br><span class="line">fa[r]=f;<span class="comment">//当前点的父节点=f</span></span><br><span class="line">siz[r]++;<span class="comment">//加上自己</span></span><br><span class="line"><span class="keyword">int</span> mx=<span class="number">0</span>;<span class="comment">//子节点中siz最大的有多大</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[r];i;i=e[i].next)<span class="comment">//遍历链接的所有点(包括父节点)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;<span class="comment">//链接点编号</span></span><br><span class="line"><span class="keyword">if</span>(to==f)<span class="keyword">continue</span>;<span class="comment">//排除父节点</span></span><br><span class="line">dfs1(to,r);<span class="comment">//dfs1(子节点，把当前点作为父节点)</span></span><br><span class="line">siz[r]+=siz[to];<span class="comment">//加上这一个子节点的数量</span></span><br><span class="line"><span class="keyword">if</span>(siz[to]&gt;mx)<span class="comment">//只要这个子节点的数量最多</span></span><br><span class="line">&#123;<span class="comment">//更新hson</span></span><br><span class="line">mx=siz[to];<span class="comment">//改变最大数</span></span><br><span class="line">hson[r]=to;<span class="comment">//改变最大链为to</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上我们就求到了dep，fa，hson，siz</p><p>下面是图</p><p><img src="/images/树链剖分2.jpg" alt></p><p>下面开始把树变成链，加在线段树上</p><p>变量：</p><div class="table-container"><table><thead><tr><th>变量名</th><th style="text-align:center">变量作用</th></tr></thead><tbody><tr><td>a[i]</td><td style="text-align:center">输入的点权</td></tr><tr><td>b[i]</td><td style="text-align:center">新增的点的点权</td></tr><tr><td>segi</td><td style="text-align:center">增加一个点</td></tr><tr><td>top[i]</td><td style="text-align:center">第i个点所属的链的头</td></tr><tr><td>pos[i]</td><td style="text-align:center">i节点在线段树中的位置</td></tr></tbody></table></div><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(rg r,rg tp)</span><span class="comment">//当前节点，这条链的最高点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">segi++;<span class="comment">//增加一个点</span></span><br><span class="line">b[segi]=a[r];<span class="comment">//把当前节点的值赋值给新增的点</span></span><br><span class="line">pos[r]=segi;<span class="comment">//当前节点在线段树中的位置</span></span><br><span class="line">top[r]=tp;<span class="comment">//当前节点所属链的头头</span></span><br><span class="line"><span class="keyword">if</span>(siz[r]==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//当前节点只有他自己</span></span><br><span class="line">dfs2(hson[r],tp);<span class="comment">//当前节点最重的一个子节点，这条链的最高点</span></span><br><span class="line"><span class="keyword">for</span>(rg i=h[r];i;i=e[i].next)<span class="comment">//遍历</span></span><br><span class="line">&#123;</span><br><span class="line">rg to=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(to==fa[r]||to==hson[r])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//只要找到的点不是父节点，不是最重点</span></span><br><span class="line">dfs2(to,to);<span class="comment">//新建一个以to为头的链</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是图</p><p><img src="/images/树链剖分3.jpg" alt></p><p>线段树中 </p><p><img src="/images/树链剖分4.jpg" alt></p><p>这样我们可以发现以x为根的所有节点就是[pos[x],pos[x]+siz[x]-1],1是减取x本身</p><p>但x到y结点最短路径上所有节点我们怎么更改呢</p><p>可以马上知道if(top[x]==top[y])(dep[x]&gt;dep[y]),那么[pos[x],pos[y]]就是需要更改的区间</p><p>但如果不在同一条链，我们就不停的让x,y移到同一条链上，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(top[x]!=top[y])<span class="comment">//不在同一条链</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&gt;dep[top[y]])swap(x,y);<span class="comment">//让x所在链与根最近</span></span><br><span class="line">    update(<span class="number">1</span>,<span class="number">1</span>,n,pos[top[y]],pos[y],p);<span class="comment">//更新从top(x)到x</span></span><br><span class="line">    y=fa[top[y]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>始终都是移动(((所在链)的头)的深度)最大的;</p><p>下面是总的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">100005</span>],fa[<span class="number">100005</span>],hson[<span class="number">100005</span>],siz[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>],b[<span class="number">100005</span>],seg[<span class="number">400005</span>],top[<span class="number">100005</span>],pos[<span class="number">100005</span>],segi=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pluss[<span class="number">400005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> next,to;&#125;;</span><br><span class="line">edge e[<span class="number">200005</span>];<span class="comment">//无向边</span></span><br><span class="line"><span class="keyword">int</span> n,m,s,v<span class="comment">/*模的数*/</span>,ei,h[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f1,<span class="keyword">int</span> f2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ei++;</span><br><span class="line">e[ei].to=f2;</span><br><span class="line">e[ei].next=h[f1];</span><br><span class="line">h[f1]=ei;</span><br><span class="line">&#125;<span class="comment">//前向星</span></span><br><span class="line"><span class="comment">//以下为线段树</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;seg[o]=(seg[o&lt;&lt;<span class="number">1</span>]+seg[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%v;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">seg[o]=b[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(o&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">build(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">pushup(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pluss[o]==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">seg[o&lt;&lt;<span class="number">1</span>]+=pluss[o]*(mid-l+<span class="number">1</span>);</span><br><span class="line">seg[o&lt;&lt;<span class="number">1</span>]%=v;</span><br><span class="line">pluss[o&lt;&lt;<span class="number">1</span>]+=pluss[o];</span><br><span class="line">pluss[o&lt;&lt;<span class="number">1</span>]%=v;</span><br><span class="line">seg[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=pluss[o]*(r-mid);</span><br><span class="line">seg[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%=v;</span><br><span class="line">pluss[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=pluss[o];</span><br><span class="line">pluss[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%=v;</span><br><span class="line">pluss[o]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line">&#123;</span><br><span class="line">seg[o]+=c*(r-l+<span class="number">1</span>);</span><br><span class="line">seg[o]%=v;</span><br><span class="line">pluss[o]+=c;</span><br><span class="line">pluss[o]%=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(o,l,r);</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid)update(o&lt;&lt;<span class="number">1</span>,l,mid,x,y,c);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid)update(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y,c);</span><br><span class="line">pushup(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)<span class="keyword">return</span> seg[o]%v;</span><br><span class="line">pushdown(o,l,r);</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid)ans+=query(o&lt;&lt;<span class="number">1</span>,l,mid,x,y);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid)ans=(ans+query(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y))%v;</span><br><span class="line"><span class="keyword">return</span> ans%v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上为线段树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为树刨</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p)</span><span class="comment">//从x到y增加p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top[x]!=top[y])<span class="comment">//不在同一条链</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[x]]&gt;dep[top[y]])swap(x,y);<span class="comment">//让x所在链与根最近</span></span><br><span class="line">update(<span class="number">1</span>,<span class="number">1</span>,n,pos[top[y]],pos[y],p);<span class="comment">//更新从top(x)到x</span></span><br><span class="line">y=fa[top[y]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">update(<span class="number">1</span>,<span class="number">1</span>,n,pos[x],pos[y],p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//查询从x到y的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[x]!=top[y])<span class="comment">//不在同一条链</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[x]]&gt;dep[top[y]])swap(x,y);<span class="comment">//让x所在链与根最近</span></span><br><span class="line">ans=(ans+query(<span class="number">1</span>,<span class="number">1</span>,n,pos[top[y]],pos[y]))%v;</span><br><span class="line">y=fa[top[y]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">ans+=query(<span class="number">1</span>,<span class="number">1</span>,n,pos[x],pos[y]);</span><br><span class="line"><span class="keyword">return</span> ans%v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> f)</span><span class="comment">//当前节点，父节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[r]=dep[f]+<span class="number">1</span>;<span class="comment">//当前深度=上一个+1</span></span><br><span class="line">fa[r]=f;<span class="comment">//父节点=f</span></span><br><span class="line">siz[r]++;<span class="comment">//加上自己的重量</span></span><br><span class="line"><span class="keyword">int</span> mx=<span class="number">0</span>;<span class="comment">//最重的链有多重</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[r];i;i=e[i].next)<span class="comment">//遍历链接的所有点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(to==f)<span class="keyword">continue</span>;</span><br><span class="line">dfs1(to,r);</span><br><span class="line">siz[r]+=siz[to];<span class="comment">//加上其中一个儿子的重量</span></span><br><span class="line"><span class="keyword">if</span>(siz[to]&gt;mx)<span class="comment">//只要to的重量最大</span></span><br><span class="line">&#123;</span><br><span class="line">mx=siz[to];<span class="comment">//改变最大</span></span><br><span class="line">hson[r]=to;<span class="comment">//改变最重链为to</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> tp)</span><span class="comment">//当前节点，这条链的最高点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">segi++;<span class="comment">//增加一个点</span></span><br><span class="line">b[segi]=a[r];<span class="comment">//把当前节点的值赋值给新增的点</span></span><br><span class="line">pos[r]=segi;<span class="comment">//当前节点在线段树中的位置</span></span><br><span class="line">top[r]=tp;<span class="comment">//当前节点所属链的头头</span></span><br><span class="line"><span class="keyword">if</span>(siz[r]==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//当前节点只有他自己</span></span><br><span class="line">dfs2(hson[r],tp);<span class="comment">//当前节点最重的一个子节点，这条链的最高点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[r];i;i=e[i].next)<span class="comment">//遍历</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(to==fa[r]||to==hson[r])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//只要找到的点不是父节点，不是最重点</span></span><br><span class="line">dfs2(to,to);<span class="comment">//新建一个以to为头头的链</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read();m=read();s=read();v=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=read();</span><br><span class="line">a[i]%=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=read(),f2=read();</span><br><span class="line">add(f1,f2);</span><br><span class="line">add(f2,f1);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(s,s);</span><br><span class="line">dfs2(s,s);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f1=read();</span><br><span class="line"><span class="keyword">if</span>(f1==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=read(),y=read(),z=read();</span><br><span class="line">updateTree(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f1==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">write(queryTree(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f1==<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=read(),z=read();</span><br><span class="line">update(<span class="number">1</span>,<span class="number">1</span>,n,pos[x],pos[x]+siz[x]<span class="number">-1</span>,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f1==<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=read();</span><br><span class="line">write(query(<span class="number">1</span>,<span class="number">1</span>,n,pos[x],pos[x]+siz[x]<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有不懂的可以下面问我</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;将一棵树划分成若干条链，用数据结构去维护每条链，复杂度为O(logN)&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="http://www.scwyl.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://www.scwyl.cn/2019/07/25/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://www.scwyl.cn/2019/07/25/背包问题/</id>
    <published>2019-07-25T15:30:00.000Z</published>
    <updated>2019-08-03T09:35:39.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>背包问题分为6种(还有更多)，之外的“有依赖的背包问题”可以展开当成分组背包做如：<a href="https://www.luogu.org/problem/P1064" target="_blank" rel="noopener">金明的预算方案</a></p><a id="more"></a><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>定义：有n种物品和一个容量为V的背包，物品i的体积为w[i]，价格为c[i]。每种物品最多选择1次，求不超过V时的最大价值，这类问题称为01背包问题 。</p><p>状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=w[i];j--)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j]=max(f[j],f[j-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f[j]表示j空间下最大价值为f[j]</span></span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>定义：有n种物品和一个容量为V的背包，物品i的体积为w[i]，价值为c[i]，每种物品可以选无数次，求不超过V时的最大价值，这类问题称为完全背包问题</p><p>状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=V;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    f[j]=max(f[j],f[j-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f[j]表示j空间下最大价值为f[j]</span></span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>定义：有n种物品和一个容量为V的背包，物品i的体积为w[i]，价值为c[i]，每种物品可以选k[i]次，求不超过V时的最大价值，这类问题称为多重背包问题<br>此类问题可转换为01背包，既然第i件物品有k[i]个，不妨展开，变成有k[i]个i件物品<br>状态转移方程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">N=n;<span class="comment">//N为展开后的物品总数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(k[i]!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        w[++N]=w[i];</span><br><span class="line">        c[N]=c[i];</span><br><span class="line">        k[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=w[i];j--)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j]=max(f[j],f[j-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f[j]表示j空间下最大价值为f[j]</span></span><br></pre></td></tr></table></figure></p><h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><p>定义：有n种物品和一个容量为V的背包，物品i的体积为w[i]，价值为c[i]，每种物品可以选1次，多次，无数次，求不超过V时的最大价值，这类问题称为混合背包问题<br>先把多次的展开，然后把1次的做成01背包，把无数次做成完全背包<br>状态转移方程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(t[i]==<span class="number">1</span>)<span class="comment">//只能选1次</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=w[i];i--)</span><br><span class="line">&#123;</span><br><span class="line">f[j]=max(f[j],f[j-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=V;i++)</span><br><span class="line">&#123;</span><br><span class="line">f[j]=max(f[j],f[j-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h3><p>定义：有n种物品和一个容量为V，最多装K千克的物品的背包，物品i的体积为w[i]，重量为l[i]，价值为c[i]，每种物品可以选1次，多次，无数次，求不超过V,K时的最大价值，这类问题称为混合背包问题<br>先把多次的展开，然后把1次的做成01背包，把无数次做成完全背包。<br>状态转移方程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(t[i]==<span class="number">1</span>)<span class="comment">//只能选1次</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=w[i];i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> o=K;o&gt;=l[i];o--)</span><br><span class="line">&#123;</span><br><span class="line">f[j][o]=max(f[j][o],f[j-w[i]][o-l[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=V;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> o=l[i];o&lt;=K;o++)</span><br><span class="line">&#123;</span><br><span class="line">f[j][o]=max(f[j][o],f[j-w[i]][o-l[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f[j][o]//为j空间下o千克物品最大价值</span></span><br></pre></td></tr></table></figure></p><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p>定义：有n种物品和一个容量为V的背包，物品i的体积为w[i]，价值为c[i]。这些物品被划分为p组，每组中的物品互相冲突，最多选一件。求不超过V时的最大价值。这类问题称为分组背包问题<br>简单来说就是n件物品分为k组，每组最多选1件。<br>状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v[i][k]=第i组第k件物品的体积</span></span><br><span class="line"><span class="comment">//c[i][k]=第i组第k件物品的价值</span></span><br><span class="line"><span class="comment">//输入的时候就可以处理以上变量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n[i];k++)<span class="comment">//n[i]为第i组有多少物品</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i][k])f[j]=max(f[j],f[j-v[i][k]]+c[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题:"></a>例题:</h3><h5 id="01背包-1"><a href="#01背包-1" class="headerlink" title="01背包"></a>01背包</h5><p><a href="https://www.luogu.org/problem/P1060" target="_blank" rel="noopener">开心的金明</a>     <a href="https://www.luogu.org/problem/P1164" target="_blank" rel="noopener">小A点菜</a>     <a href="https://www.luogu.org/problem/P1048" target="_blank" rel="noopener">采药</a>     <a href="https://www.luogu.org/problem/P1049" target="_blank" rel="noopener">装箱</a></p><h5 id="完全背包-1"><a href="#完全背包-1" class="headerlink" title="完全背包"></a>完全背包</h5><p><a href="https://www.luogu.org/problem/P1616" target="_blank" rel="noopener">疯狂采药</a>     <a href="https://www.luogu.org/problem/P5020" target="_blank" rel="noopener">货币系统</a></p><h5 id="多重背包-1"><a href="#多重背包-1" class="headerlink" title="多重背包"></a>多重背包</h5><p><a href="https://www.luogu.org/problem/P1782" target="_blank" rel="noopener">旅行商的背包</a>     <a href="https://www.luogu.org/problem/P2347" target="_blank" rel="noopener">砝码称重</a></p><h5 id="混合背包-1"><a href="#混合背包-1" class="headerlink" title="混合背包"></a>混合背包</h5><p><a href="https://www.luogu.org/problem/P1833" target="_blank" rel="noopener">樱花</a></p><h5 id="二维费用背包-1"><a href="#二维费用背包-1" class="headerlink" title="二维费用背包"></a>二维费用背包</h5><p><a href="https://www.luogu.org/problem/P1855" target="_blank" rel="noopener">榨取kkksc03</a>     <a href="https://www.luogu.org/problem/P1507" target="_blank" rel="noopener">NASA的食物计划</a></p><h5 id="分组背包-1"><a href="#分组背包-1" class="headerlink" title="分组背包"></a>分组背包</h5><p><a href="https://www.luogu.org/problem/P1757" target="_blank" rel="noopener">通天之分组背包</a></p><p>最后。。。有哪里写错误，或者哪里没懂可以在下方评论，看到的第一时间我会处理</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;背包问题分为6种(还有更多)，之外的“有依赖的背包问题”可以展开当成分组背包做如：&lt;a href=&quot;https://www.luogu.org/problem/P1064&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;金明的预算方案&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://www.scwyl.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>区间DP</title>
    <link href="http://www.scwyl.cn/2019/07/24/%E5%8C%BA%E9%97%B4DP/"/>
    <id>http://www.scwyl.cn/2019/07/24/区间DP/</id>
    <published>2019-07-24T15:30:00.000Z</published>
    <updated>2019-08-03T09:35:22.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>区间简单来说就是一坨；</p><p>区间DP就是当前这一坨(与之前那一坨的关系)或者(与之后那一坨的关系)。</p><a id="more"></a><p><a href="https://www.luogu.org/space/show?uid=110871" target="_blank" rel="noopener">我的洛谷</a>,求一波关注。。。</p><p>本次例题：<a href="https://www.luogu.org/problem/P1005" target="_blank" rel="noopener">矩阵取数游戏</a></p><p>对于一个给定的<em>n</em>×<em>m</em>的矩阵</p><ol><li>每次取数时须从每行各取走一个元素，共<em>n</em>个。经过<em>m</em>次后取完矩阵内所有元素；</li><li>每次取走的各个元素只能是该元素所在行的行首或行尾；</li><li>每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值2^<em>i</em>，其中<em>i</em>表示第<em>i</em>次取数（从1开始编号）；</li><li>游戏结束总得分为<em>m</em>次取数得分之和。<br>最后输出最大得分</li></ol><div class="table-container"><table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>2 3<br>1 2 3<br>3 4 2</td><td>82</td></tr><tr><td>1 4<br>4 5 0 5</td><td>122</td></tr><tr><td>2 10<br>96 56 54 46 86 12 23 88 80 43<br>16 95 18 29 30 53 88 83 64 67</td><td>316994</td></tr></tbody></table></div><p>以上有三组样例。</p><p>数据范围说是最大是80*80的矩阵，每个数小于1000，2^80会超过longlong,所以我们用2个longlong拼接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000000000000<span class="comment">//1后面15个0</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int127</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> G,D;<span class="comment">//高位，低位</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> int127&amp;x)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((G&lt;x.G)||(G==x.G&amp;&amp;D&lt;x.D))<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//小就返回1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> int127&amp;x)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((G&gt;x.G)||(G==x.G&amp;&amp;D&gt;x.D))<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//小就返回1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">int127 <span class="keyword">operator</span> + (<span class="keyword">const</span> int127&amp;x)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">int127 ans;</span><br><span class="line">ans.G=<span class="number">0</span>;ans.D=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">ans.G=G+x.G+(x.D+D)/mod;</span><br><span class="line">ans.D=(x.D+D)%mod;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">int127 <span class="keyword">operator</span> + (<span class="keyword">const</span> <span class="keyword">int</span>&amp;x)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">int127 ans;</span><br><span class="line">ans.G=<span class="number">0</span>;ans.D=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">ans.G=G+(x+D)/mod;</span><br><span class="line">ans.D=(x+D)%mod;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">int127 <span class="keyword">operator</span> * (<span class="keyword">const</span> <span class="keyword">int</span>&amp;x)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">int127 ans;</span><br><span class="line">ans.G=<span class="number">0</span>;ans.D=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">ans.G=x*G+x*D/mod;</span><br><span class="line">ans.D=(x*D)%mod;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int127 k,anser,f[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//k为2^i,anser为最后答案,f为DP数组</span></span><br><span class="line"><span class="keyword">int</span> n,m,dt[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dt[j]);<span class="comment">//读一行处理一行</span></span><br><span class="line">k.D=<span class="number">1</span>;</span><br><span class="line">k.G=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=m;l&gt;<span class="number">0</span>;l--)<span class="comment">//慢慢缩小范围，从取最后一个数推到取第一个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;=l;a++)k=k*<span class="number">2</span>;<span class="comment">//2^i</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=l;o++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=m-l+o;<span class="comment">//区间大小为m-l</span></span><br><span class="line">f[o][j]=max(f[o][j<span class="number">-1</span>]+k*dt[j],f[o+<span class="number">1</span>][j]+k*dt[o]);</span><br><span class="line"><span class="comment">//区间[o,j]的分数=max(区间[o,j-1]的分加上这一次取dt[j]的分，区间[o+1,j]的分加上这一次取dt[o]的分)</span></span><br><span class="line"><span class="comment">//这一次的分数=上一次的分数加上最左边与最右边；</span></span><br><span class="line"><span class="comment">//具体就这意思，可能这次例题弄得比较难，不容易理解，多刷些题，慢慢会有感觉的</span></span><br><span class="line">&#125;</span><br><span class="line">k.D=<span class="number">1</span>;</span><br><span class="line">k.G=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line">  anser=anser+f[<span class="number">1</span>][m];<span class="comment">//加上最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(anser.G==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"%lld"</span>,anser.D);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld%lld"</span>,anser.G,anser.D);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h6><p><a href="https://www.luogu.org/problem/P1880" target="_blank" rel="noopener">石子合并</a></p><p><a href="https://www.luogu.org/problem/P1040" target="_blank" rel="noopener">加分二叉树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;区间简单来说就是一坨；&lt;/p&gt;
&lt;p&gt;区间DP就是当前这一坨(与之前那一坨的关系)或者(与之后那一坨的关系)。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://www.scwyl.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>线性DP</title>
    <link href="http://www.scwyl.cn/2019/07/24/%E7%BA%BF%E6%80%A7DP/"/>
    <id>http://www.scwyl.cn/2019/07/24/线性DP/</id>
    <published>2019-07-23T16:30:00.000Z</published>
    <updated>2019-08-03T09:34:33.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线性动规就是说所有数据的关系排列起来像一条线，如：123456，f[i]=f[i-1]+1;</p><a id="more"></a><p>本次例题：<a href="https://www.luogu.org/problem/P1091" target="_blank" rel="noopener">合唱队形</a>,<a href="https://www.luogu.org/problem/P1020" target="_blank" rel="noopener">导弹拦截</a></p><p>当然，还有更难的题目：<a href="https://www.luogu.org/problem/P2487" target="_blank" rel="noopener">拦截导弹</a>，<a href="https://www.luogu.org/problem/P3205" target="_blank" rel="noopener">合唱队</a></p><h3 id="合唱队形"><a href="#合唱队形" class="headerlink" title="合唱队形"></a>合唱队形</h3><p>题目描述太过冗长，简单来说就是给你N个数，让你丢掉ans个数，使剩下的数符合↗↘的样式，求ans最小值；</p><p>分析：先求以每个数为结尾的最长升序，再求以每个数为开头的最长降序，最后挑个最大的，用n减去再加1(因为这数被减了2次)；</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//求最长升</span></span><br><span class="line">&#123;</span><br><span class="line">dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[j])dp[<span class="number">0</span>][i]=max(dp[<span class="number">0</span>][j]+<span class="number">1</span>,dp[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="comment">//如果满足条件，以i结束的最长升=之前最长的+1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)<span class="comment">//求最长降</span></span><br><span class="line">&#123;</span><br><span class="line">dp[n][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;i;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[j])dp[n][i]=max(dp[n][j]+<span class="number">1</span>,dp[n][i]);</span><br><span class="line">        <span class="comment">//如果满足条件，以i开始的最长降=之前最长的+1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sm=max(dp[n][i]+dp[<span class="number">0</span>][i]<span class="number">-1</span>,sm);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,n-sm);</span><br></pre></td></tr></table></figure><h3 id="导弹拦截"><a href="#导弹拦截" class="headerlink" title="导弹拦截"></a>导弹拦截</h3><p>emmm…看到这题，这奇葩的输入格式。。。快读啊！</p><p>快读，就是快速读入，是用getchar()拼出来的,下面给一个读入int的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;<span class="string">'9'</span>||s&lt;<span class="string">'0'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) &#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这题我们不能这么用，得改改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">if</span>(s==EOF)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;<span class="string">'9'</span>||s&lt;<span class="string">'0'</span>)s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) &#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(s^<span class="number">48</span>);s=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先一问一问的看</p><p>第一问让我们求最长下降序列，很简单,由于数据量比较大，我们得用n*logn的办法；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=upper_bound(f+<span class="number">1</span>,f+<span class="number">1</span>+k,a[i],greater&lt;<span class="keyword">int</span>&gt;())-f;</span><br><span class="line">    <span class="comment">//这里求出的pos表示f[pos]&lt;=a[i];</span></span><br><span class="line">    <span class="keyword">if</span>(f[k]&gt;=a[i])</span><br><span class="line">    &#123;</span><br><span class="line">        f[++k]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[pos]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k);</span><br></pre></td></tr></table></figure><p>第二问</p><p>代码很简单，也可以参照第一问用lower_bound解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ff[<span class="number">0</span>]=<span class="number">50001</span><span class="comment">//设为最大高度+1；</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> h=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=js;j++)<span class="comment">//让所有系统都去试试</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ff[j]&gt;=a[i]&amp;&amp;ff[j]&lt;ff[h])<span class="comment">//贪心思想</span></span><br><span class="line">        &#123;</span><br><span class="line">            h=j;<span class="comment">//把这套系统的序号记录下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h==<span class="number">0</span>)ff[++js]=a[i];<span class="comment">//只要a[i]没有被之前的系统拦住，就新建一系统</span></span><br><span class="line">    <span class="keyword">else</span> ff[h]=a[i];<span class="comment">//拦住了，就把拦住a[i]的那系统高度降低</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,js);<span class="comment">//输出计数</span></span><br></pre></td></tr></table></figure><p>有不懂的可以下面问我</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;线性动规就是说所有数据的关系排列起来像一条线，如：123456，f[i]=f[i-1]+1;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://www.scwyl.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>状态压缩</title>
    <link href="http://www.scwyl.cn/2019/07/22/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    <id>http://www.scwyl.cn/2019/07/22/状态压缩/</id>
    <published>2019-07-22T15:00:00.000Z</published>
    <updated>2019-08-03T09:34:17.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>状态压缩[状压],是通过2进制来优化空间的一种方法</p><a id="more"></a><p>一个int是2^31 -1,写成二进制就是0111 1111 1111 1111 1111 1111 1111 1111,总共31个‘1’。</p><p>当我们储存一个数据只有很少的状态时就可以通过状压实现优化内存。</p><p>举例：</p><p>​    在20件物品中，分别编号1~20，</p><h6 id="1-选上某物品："><a href="#1-选上某物品：" class="headerlink" title="1.选上某物品："></a>1.选上某物品：</h6><p>平时我们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use[编号]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>而现在就可以用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use=(use|(<span class="number">1</span>&lt;&lt;(编号<span class="number">-1</span>)));</span><br></pre></td></tr></table></figure><p>比如说我要选第5件:</p><p>那么use就会变成0001 0000</p><p>在选上第2件</p><p>use: 0001 0010</p><h6 id="2-选了多少个，"><a href="#2-选了多少个，" class="headerlink" title="2.选了多少个，"></a>2.选了多少个，</h6><p>就是统计1的个数，很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        p+=(x&amp;<span class="number">1</span>);</span><br><span class="line">        x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-如果要一下子全部选呢"><a href="#3-如果要一下子全部选呢" class="headerlink" title="3.如果要一下子全部选呢"></a>3.如果要一下子全部选呢</h6><p>可以用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use=<span class="number">1</span>&lt;&lt;(<span class="number">20</span>+<span class="number">1</span>)<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h6 id="4-不选某一个物品"><a href="#4-不选某一个物品" class="headerlink" title="4.不选某一个物品"></a>4.不选某一个物品</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.u</span>se|(<span class="number">1</span>&lt;&lt;(编号<span class="number">-1</span>))-(<span class="number">1</span>&lt;&lt;(编号<span class="number">-1</span>));</span><br><span class="line"><span class="number">2.u</span>se&amp;(~(<span class="number">1</span>&lt;&lt;(编号<span class="number">-1</span>)));</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">get:</span><br><span class="line"><span class="number">1.</span>求出x的第k位:(x&gt;&gt;(k<span class="number">-1</span>))&amp;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">set</span>:</span><br><span class="line"><span class="number">1.</span>把x的第k位改为<span class="number">1</span>:x|(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line"><span class="number">2.</span>把x的第k位改为<span class="number">0</span>:<span class="number">1.</span>x|(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))-(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">  或者:<span class="number">2.</span>x&amp;(~(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>)));</span><br><span class="line"><span class="number">3.</span><span class="keyword">if</span>(x&amp;(x&lt;&lt;<span class="number">1</span>)!=<span class="number">0</span>)就表示有相临的‘<span class="number">1</span>’;如<span class="number">0110</span>或<span class="number">1011</span></span><br><span class="line"><span class="number">4.</span>取k位全是<span class="number">1</span>:<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>)<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;状态压缩[状压],是通过2进制来优化空间的一种方法&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.scwyl.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="状压" scheme="http://www.scwyl.cn/tags/%E7%8A%B6%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>简述动态规划</title>
    <link href="http://www.scwyl.cn/2019/07/22/%E7%AE%80%E8%BF%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://www.scwyl.cn/2019/07/22/简述动态规划/</id>
    <published>2019-07-22T14:30:00.000Z</published>
    <updated>2019-08-03T09:34:51.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。</p><a id="more"></a><p>动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。</p><p>举例：</p><p>线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；</p><p>区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；</p><p>树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；</p><p>背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶；</p><p>//以上摘自百度百科</p><p>有时还会遇到状态压缩加动态规划</p><p>目录：</p><p><a href="\2019\07\22\状态压缩\">状态压缩</a></p><p><a href="\2019\07\24\线性DP\">线性动规</a></p><p><a href="\2019\07\24\区间DP\">区域动规</a></p><p><a href="\2019\07\25\背包问题\">背包问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。&lt;/p&gt;
    
    </summary>
    
      <category term="目录" scheme="http://www.scwyl.cn/categories/%E7%9B%AE%E5%BD%95/"/>
    
    
      <category term="动态规划" scheme="http://www.scwyl.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
